// <auto-generated>
/*
 * Whisper API Platform
 *
 * Whisper provides comprehensive intelligence and monitoring capabilities for domains, IPs, and web infrastructure. Access powerful APIs for WHOIS data, DNS analysis, screenshot capture, network intelligence, and more - all through a unified, authenticated interface.  **Key Features:** • Domain intelligence and subdomain discovery • IP geolocation and network analysis • Real-time and historical WHOIS data • Automated website screenshot capture • Network relationship mapping • BGP routing and security intelligence • Infrastructure monitoring and health checks  **Authentication:** All endpoints require Bearer token authentication. Contact support for API access.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api-support@whisper.security
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Noctis.FrontGraph.Sdk.Client;

namespace Noctis.FrontGraph.Sdk.Model
{
    /// <summary>
    /// Results and status information for an asynchronous domain search request (similarity or free-text)
    /// </summary>
    public partial class DomainerAsyncResultDTO : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DomainerAsyncResultDTO" /> class.
        /// </summary>
        /// <param name="requestId">Unique identifier for the request</param>
        /// <param name="limit">Maximum number of results requested</param>
        /// <param name="createdAt">Time when the request was created</param>
        /// <param name="status">Request status</param>
        /// <param name="domainName">Domain name that was searched</param>
        /// <param name="similarityType">similarityType</param>
        /// <param name="queryString">Query string used for the search (only for SEARCH requests)</param>
        /// <param name="operator">Default operator used between query terms (only for SEARCH requests)</param>
        /// <param name="level">Absolute domain level filter applied (only for SEARCH requests)</param>
        /// <param name="completedAt">Time when the request was completed (null if still processing)</param>
        /// <param name="results">List of similar domains found (null if still processing)</param>
        /// <param name="resultCount">Total number of results found</param>
        /// <param name="processingTimeMs">Time taken to process the request in milliseconds (-1 if still processing)</param>
        [JsonConstructor]
        public DomainerAsyncResultDTO(Guid requestId, int limit, DateTime createdAt, StatusEnum status, Option<string?> domainName = default, Option<DomainerSimilarityType?> similarityType = default, Option<string?> queryString = default, Option<OperatorEnum?> @operator = default, Option<LevelEnum?> level = default, Option<DateTime?> completedAt = default, Option<List<string>?> results = default, Option<int?> resultCount = default, Option<long?> processingTimeMs = default)
        {
            RequestId = requestId;
            Limit = limit;
            CreatedAt = createdAt;
            Status = status;
            DomainNameOption = domainName;
            SimilarityTypeOption = similarityType;
            QueryStringOption = queryString;
            OperatorOption = @operator;
            LevelOption = level;
            CompletedAtOption = completedAt;
            ResultsOption = results;
            ResultCountOption = resultCount;
            ProcessingTimeMsOption = processingTimeMs;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Request status
        /// </summary>
        /// <value>Request status</value>
        public enum StatusEnum
        {
            /// <summary>
            /// Enum PROCESSING for value: PROCESSING
            /// </summary>
            PROCESSING = 1,

            /// <summary>
            /// Enum COMPLETED for value: COMPLETED
            /// </summary>
            COMPLETED = 2
        }

        /// <summary>
        /// Returns a <see cref="StatusEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static StatusEnum StatusEnumFromString(string value)
        {
            if (value.Equals("PROCESSING"))
                return StatusEnum.PROCESSING;

            if (value.Equals("COMPLETED"))
                return StatusEnum.COMPLETED;

            throw new NotImplementedException($"Could not convert value to type StatusEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="StatusEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static StatusEnum? StatusEnumFromStringOrDefault(string value)
        {
            if (value.Equals("PROCESSING"))
                return StatusEnum.PROCESSING;

            if (value.Equals("COMPLETED"))
                return StatusEnum.COMPLETED;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="StatusEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string StatusEnumToJsonValue(StatusEnum value)
        {
            if (value == StatusEnum.PROCESSING)
                return "PROCESSING";

            if (value == StatusEnum.COMPLETED)
                return "COMPLETED";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Request status
        /// </summary>
        /// <value>Request status</value>
        /* <example>COMPLETED</example> */
        [JsonPropertyName("status")]
        public StatusEnum Status { get; }

        /// <summary>
        /// Used to track the state of SimilarityType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DomainerSimilarityType?> SimilarityTypeOption { get; private set; }

        /// <summary>
        /// Gets or Sets SimilarityType
        /// </summary>
        [JsonPropertyName("similarityType")]
        public DomainerSimilarityType? SimilarityType { get { return this.SimilarityTypeOption; } set { this.SimilarityTypeOption = new(value); } }

        /// <summary>
        /// Default operator used between query terms (only for SEARCH requests)
        /// </summary>
        /// <value>Default operator used between query terms (only for SEARCH requests)</value>
        public enum OperatorEnum
        {
            /// <summary>
            /// Enum AND for value: AND
            /// </summary>
            AND = 1,

            /// <summary>
            /// Enum OR for value: OR
            /// </summary>
            OR = 2
        }

        /// <summary>
        /// Returns a <see cref="OperatorEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static OperatorEnum OperatorEnumFromString(string value)
        {
            if (value.Equals("AND"))
                return OperatorEnum.AND;

            if (value.Equals("OR"))
                return OperatorEnum.OR;

            throw new NotImplementedException($"Could not convert value to type OperatorEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="OperatorEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static OperatorEnum? OperatorEnumFromStringOrDefault(string value)
        {
            if (value.Equals("AND"))
                return OperatorEnum.AND;

            if (value.Equals("OR"))
                return OperatorEnum.OR;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="OperatorEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string? OperatorEnumToJsonValue(OperatorEnum? value)
        {
            if (value == null)
                return null;

            if (value == OperatorEnum.AND)
                return "AND";

            if (value == OperatorEnum.OR)
                return "OR";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of Operator
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<OperatorEnum?> OperatorOption { get; }

        /// <summary>
        /// Default operator used between query terms (only for SEARCH requests)
        /// </summary>
        /// <value>Default operator used between query terms (only for SEARCH requests)</value>
        /* <example>AND</example> */
        [JsonPropertyName("operator")]
        public OperatorEnum? Operator { get { return this.OperatorOption; } }

        /// <summary>
        /// Absolute domain level filter applied (only for SEARCH requests)
        /// </summary>
        /// <value>Absolute domain level filter applied (only for SEARCH requests)</value>
        public enum LevelEnum
        {
            /// <summary>
            /// Enum ALL for value: ALL
            /// </summary>
            ALL = 1,

            /// <summary>
            /// Enum IMMEDIATE for value: IMMEDIATE
            /// </summary>
            IMMEDIATE = 2,

            /// <summary>
            /// Enum MAXDEPTH for value: MAX_DEPTH
            /// </summary>
            MAXDEPTH = 3
        }

        /// <summary>
        /// Returns a <see cref="LevelEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static LevelEnum LevelEnumFromString(string value)
        {
            if (value.Equals("ALL"))
                return LevelEnum.ALL;

            if (value.Equals("IMMEDIATE"))
                return LevelEnum.IMMEDIATE;

            if (value.Equals("MAX_DEPTH"))
                return LevelEnum.MAXDEPTH;

            throw new NotImplementedException($"Could not convert value to type LevelEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="LevelEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static LevelEnum? LevelEnumFromStringOrDefault(string value)
        {
            if (value.Equals("ALL"))
                return LevelEnum.ALL;

            if (value.Equals("IMMEDIATE"))
                return LevelEnum.IMMEDIATE;

            if (value.Equals("MAX_DEPTH"))
                return LevelEnum.MAXDEPTH;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="LevelEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string? LevelEnumToJsonValue(LevelEnum? value)
        {
            if (value == null)
                return null;

            if (value == LevelEnum.ALL)
                return "ALL";

            if (value == LevelEnum.IMMEDIATE)
                return "IMMEDIATE";

            if (value == LevelEnum.MAXDEPTH)
                return "MAX_DEPTH";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of Level
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<LevelEnum?> LevelOption { get; }

        /// <summary>
        /// Absolute domain level filter applied (only for SEARCH requests)
        /// </summary>
        /// <value>Absolute domain level filter applied (only for SEARCH requests)</value>
        /* <example>ALL</example> */
        [JsonPropertyName("level")]
        public LevelEnum? Level { get { return this.LevelOption; } }

        /// <summary>
        /// Unique identifier for the request
        /// </summary>
        /// <value>Unique identifier for the request</value>
        /* <example>123e4567-e89b-12d3-a456-426614174000</example> */
        [JsonPropertyName("requestId")]
        public Guid RequestId { get; }

        /// <summary>
        /// Maximum number of results requested
        /// </summary>
        /// <value>Maximum number of results requested</value>
        /* <example>100</example> */
        [JsonPropertyName("limit")]
        public int Limit { get; }

        /// <summary>
        /// Time when the request was created
        /// </summary>
        /// <value>Time when the request was created</value>
        [JsonPropertyName("createdAt")]
        public DateTime CreatedAt { get; }

        /// <summary>
        /// Used to track the state of DomainName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DomainNameOption { get; }

        /// <summary>
        /// Domain name that was searched
        /// </summary>
        /// <value>Domain name that was searched</value>
        /* <example>example.com</example> */
        [JsonPropertyName("domainName")]
        public string? DomainName { get { return this.DomainNameOption; } }

        /// <summary>
        /// Used to track the state of QueryString
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> QueryStringOption { get; }

        /// <summary>
        /// Query string used for the search (only for SEARCH requests)
        /// </summary>
        /// <value>Query string used for the search (only for SEARCH requests)</value>
        /* <example>exampl~ OR &quot;domain search&quot; OR prefix*</example> */
        [JsonPropertyName("queryString")]
        public string? QueryString { get { return this.QueryStringOption; } }

        /// <summary>
        /// Used to track the state of CompletedAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> CompletedAtOption { get; }

        /// <summary>
        /// Time when the request was completed (null if still processing)
        /// </summary>
        /// <value>Time when the request was completed (null if still processing)</value>
        [JsonPropertyName("completedAt")]
        public DateTime? CompletedAt { get { return this.CompletedAtOption; } }

        /// <summary>
        /// Used to track the state of Results
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> ResultsOption { get; }

        /// <summary>
        /// List of similar domains found (null if still processing)
        /// </summary>
        /// <value>List of similar domains found (null if still processing)</value>
        [JsonPropertyName("results")]
        public List<string>? Results { get { return this.ResultsOption; } }

        /// <summary>
        /// Used to track the state of ResultCount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ResultCountOption { get; }

        /// <summary>
        /// Total number of results found
        /// </summary>
        /// <value>Total number of results found</value>
        /* <example>42</example> */
        [JsonPropertyName("resultCount")]
        public int? ResultCount { get { return this.ResultCountOption; } }

        /// <summary>
        /// Used to track the state of ProcessingTimeMs
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> ProcessingTimeMsOption { get; }

        /// <summary>
        /// Time taken to process the request in milliseconds (-1 if still processing)
        /// </summary>
        /// <value>Time taken to process the request in milliseconds (-1 if still processing)</value>
        /* <example>1542</example> */
        [JsonPropertyName("processingTimeMs")]
        public long? ProcessingTimeMs { get { return this.ProcessingTimeMsOption; } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DomainerAsyncResultDTO {\n");
            sb.Append("  RequestId: ").Append(RequestId).Append("\n");
            sb.Append("  Limit: ").Append(Limit).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  DomainName: ").Append(DomainName).Append("\n");
            sb.Append("  SimilarityType: ").Append(SimilarityType).Append("\n");
            sb.Append("  QueryString: ").Append(QueryString).Append("\n");
            sb.Append("  Operator: ").Append(Operator).Append("\n");
            sb.Append("  Level: ").Append(Level).Append("\n");
            sb.Append("  CompletedAt: ").Append(CompletedAt).Append("\n");
            sb.Append("  Results: ").Append(Results).Append("\n");
            sb.Append("  ResultCount: ").Append(ResultCount).Append("\n");
            sb.Append("  ProcessingTimeMs: ").Append(ProcessingTimeMs).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Limit (int) minimum
            if (this.Limit < (int)1)
            {
                yield return new ValidationResult("Invalid value for Limit, must be a value greater than or equal to 1.", new [] { "Limit" });
            }

            // ResultCount (int) minimum
            if (this.ResultCountOption.IsSet && this.ResultCountOption.Value < (int)0)
            {
                yield return new ValidationResult("Invalid value for ResultCount, must be a value greater than or equal to 0.", new [] { "ResultCount" });
            }

            // ProcessingTimeMs (long) minimum
            if (this.ProcessingTimeMsOption.IsSet && this.ProcessingTimeMsOption.Value < (long)-1)
            {
                yield return new ValidationResult("Invalid value for ProcessingTimeMs, must be a value greater than or equal to -1.", new [] { "ProcessingTimeMs" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="DomainerAsyncResultDTO" />
    /// </summary>
    public class DomainerAsyncResultDTOJsonConverter : JsonConverter<DomainerAsyncResultDTO>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize CompletedAt
        /// </summary>
        public static string CompletedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="DomainerAsyncResultDTO" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override DomainerAsyncResultDTO Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Guid?> requestId = default;
            Option<int?> limit = default;
            Option<DateTime?> createdAt = default;
            Option<DomainerAsyncResultDTO.StatusEnum?> status = default;
            Option<string?> domainName = default;
            Option<DomainerSimilarityType?> similarityType = default;
            Option<string?> queryString = default;
            Option<DomainerAsyncResultDTO.OperatorEnum?> varOperator = default;
            Option<DomainerAsyncResultDTO.LevelEnum?> level = default;
            Option<DateTime?> completedAt = default;
            Option<List<string>?> results = default;
            Option<int?> resultCount = default;
            Option<long?> processingTimeMs = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "requestId":
                            requestId = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "limit":
                            limit = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "createdAt":
                            createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "status":
                            string? statusRawValue = utf8JsonReader.GetString();
                            if (statusRawValue != null)
                                status = new Option<DomainerAsyncResultDTO.StatusEnum?>(DomainerAsyncResultDTO.StatusEnumFromStringOrDefault(statusRawValue));
                            break;
                        case "domainName":
                            domainName = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "similarityType":
                            string? similarityTypeRawValue = utf8JsonReader.GetString();
                            if (similarityTypeRawValue != null)
                                similarityType = new Option<DomainerSimilarityType?>(DomainerSimilarityTypeValueConverter.FromStringOrDefault(similarityTypeRawValue));
                            break;
                        case "queryString":
                            queryString = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "operator":
                            string? varOperatorRawValue = utf8JsonReader.GetString();
                            if (varOperatorRawValue != null)
                                varOperator = new Option<DomainerAsyncResultDTO.OperatorEnum?>(DomainerAsyncResultDTO.OperatorEnumFromStringOrDefault(varOperatorRawValue));
                            break;
                        case "level":
                            string? levelRawValue = utf8JsonReader.GetString();
                            if (levelRawValue != null)
                                level = new Option<DomainerAsyncResultDTO.LevelEnum?>(DomainerAsyncResultDTO.LevelEnumFromStringOrDefault(levelRawValue));
                            break;
                        case "completedAt":
                            completedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime?>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "results":
                            results = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "resultCount":
                            resultCount = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "processingTimeMs":
                            processingTimeMs = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!requestId.IsSet)
                throw new ArgumentException("Property is required for class DomainerAsyncResultDTO.", nameof(requestId));

            if (!limit.IsSet)
                throw new ArgumentException("Property is required for class DomainerAsyncResultDTO.", nameof(limit));

            if (!createdAt.IsSet)
                throw new ArgumentException("Property is required for class DomainerAsyncResultDTO.", nameof(createdAt));

            if (!status.IsSet)
                throw new ArgumentException("Property is required for class DomainerAsyncResultDTO.", nameof(status));

            if (requestId.IsSet && requestId.Value == null)
                throw new ArgumentNullException(nameof(requestId), "Property is not nullable for class DomainerAsyncResultDTO.");

            if (limit.IsSet && limit.Value == null)
                throw new ArgumentNullException(nameof(limit), "Property is not nullable for class DomainerAsyncResultDTO.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class DomainerAsyncResultDTO.");

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status), "Property is not nullable for class DomainerAsyncResultDTO.");

            if (domainName.IsSet && domainName.Value == null)
                throw new ArgumentNullException(nameof(domainName), "Property is not nullable for class DomainerAsyncResultDTO.");

            if (similarityType.IsSet && similarityType.Value == null)
                throw new ArgumentNullException(nameof(similarityType), "Property is not nullable for class DomainerAsyncResultDTO.");

            if (resultCount.IsSet && resultCount.Value == null)
                throw new ArgumentNullException(nameof(resultCount), "Property is not nullable for class DomainerAsyncResultDTO.");

            if (processingTimeMs.IsSet && processingTimeMs.Value == null)
                throw new ArgumentNullException(nameof(processingTimeMs), "Property is not nullable for class DomainerAsyncResultDTO.");

            return new DomainerAsyncResultDTO(requestId.Value!.Value!, limit.Value!.Value!, createdAt.Value!.Value!, status.Value!.Value!, domainName, similarityType, queryString, varOperator, level, completedAt, results, resultCount, processingTimeMs);
        }

        /// <summary>
        /// Serializes a <see cref="DomainerAsyncResultDTO" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="domainerAsyncResultDTO"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, DomainerAsyncResultDTO domainerAsyncResultDTO, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, domainerAsyncResultDTO, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="DomainerAsyncResultDTO" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="domainerAsyncResultDTO"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, DomainerAsyncResultDTO domainerAsyncResultDTO, JsonSerializerOptions jsonSerializerOptions)
        {
            if (domainerAsyncResultDTO.DomainNameOption.IsSet && domainerAsyncResultDTO.DomainName == null)
                throw new ArgumentNullException(nameof(domainerAsyncResultDTO.DomainName), "Property is required for class DomainerAsyncResultDTO.");

            writer.WriteString("requestId", domainerAsyncResultDTO.RequestId);

            writer.WriteNumber("limit", domainerAsyncResultDTO.Limit);

            writer.WriteString("createdAt", domainerAsyncResultDTO.CreatedAt.ToString(CreatedAtFormat));

            var statusRawValue = DomainerAsyncResultDTO.StatusEnumToJsonValue(domainerAsyncResultDTO.Status);
            writer.WriteString("status", statusRawValue);
            if (domainerAsyncResultDTO.DomainNameOption.IsSet)
                writer.WriteString("domainName", domainerAsyncResultDTO.DomainName);

            if (domainerAsyncResultDTO.SimilarityTypeOption.IsSet)
            {
                var similarityTypeRawValue = DomainerSimilarityTypeValueConverter.ToJsonValue(domainerAsyncResultDTO.SimilarityType!.Value);
                writer.WriteString("similarityType", similarityTypeRawValue);
            }
            if (domainerAsyncResultDTO.QueryStringOption.IsSet)
                if (domainerAsyncResultDTO.QueryStringOption.Value != null)
                    writer.WriteString("queryString", domainerAsyncResultDTO.QueryString);
                else
                    writer.WriteNull("queryString");

            var varOperatorRawValue = DomainerAsyncResultDTO.OperatorEnumToJsonValue(domainerAsyncResultDTO.OperatorOption.Value!.Value);
            if (varOperatorRawValue != null)
                writer.WriteString("operator", varOperatorRawValue);
            else
                writer.WriteNull("operator");

            var levelRawValue = DomainerAsyncResultDTO.LevelEnumToJsonValue(domainerAsyncResultDTO.LevelOption.Value!.Value);
            if (levelRawValue != null)
                writer.WriteString("level", levelRawValue);
            else
                writer.WriteNull("level");

            if (domainerAsyncResultDTO.CompletedAtOption.IsSet)
                if (domainerAsyncResultDTO.CompletedAtOption.Value != null)
                    writer.WriteString("completedAt", domainerAsyncResultDTO.CompletedAtOption.Value!.Value.ToString(CompletedAtFormat));
                else
                    writer.WriteNull("completedAt");

            if (domainerAsyncResultDTO.ResultsOption.IsSet)
                if (domainerAsyncResultDTO.ResultsOption.Value != null)
                {
                    writer.WritePropertyName("results");
                    JsonSerializer.Serialize(writer, domainerAsyncResultDTO.Results, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("results");
            if (domainerAsyncResultDTO.ResultCountOption.IsSet)
                writer.WriteNumber("resultCount", domainerAsyncResultDTO.ResultCountOption.Value!.Value);

            if (domainerAsyncResultDTO.ProcessingTimeMsOption.IsSet)
                writer.WriteNumber("processingTimeMs", domainerAsyncResultDTO.ProcessingTimeMsOption.Value!.Value);
        }
    }
}
