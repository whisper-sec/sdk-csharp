// <auto-generated>
/*
 * Whisper Security API
 *
 * Enterprise threat intelligence and security operations API
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Whisper.Api.Sdk.Client;

namespace Whisper.Api.Sdk.Model
{
    /// <summary>
    /// Configuration for homoglyph (look-alike character) variations
    /// </summary>
    public partial class HomoglyphConfig : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="HomoglyphConfig" /> class.
        /// </summary>
        /// <param name="cyrillic">Include Cyrillic character substitutions (default to true)</param>
        /// <param name="greek">Include Greek character substitutions (default to true)</param>
        /// <param name="latin">Include Latin character substitutions (default to true)</param>
        /// <param name="maxSubstitutions">Maximum number of character substitutions per domain (default to 2)</param>
        [JsonConstructor]
        public HomoglyphConfig(Option<bool?> cyrillic = default, Option<bool?> greek = default, Option<bool?> latin = default, Option<int?> maxSubstitutions = default)
        {
            CyrillicOption = cyrillic;
            GreekOption = greek;
            LatinOption = latin;
            MaxSubstitutionsOption = maxSubstitutions;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of Cyrillic
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> CyrillicOption { get; private set; }

        /// <summary>
        /// Include Cyrillic character substitutions
        /// </summary>
        /// <value>Include Cyrillic character substitutions</value>
        /* <example>true</example> */
        [JsonPropertyName("cyrillic")]
        public bool? Cyrillic { get { return this.CyrillicOption; } set { this.CyrillicOption = new(value); } }

        /// <summary>
        /// Used to track the state of Greek
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> GreekOption { get; private set; }

        /// <summary>
        /// Include Greek character substitutions
        /// </summary>
        /// <value>Include Greek character substitutions</value>
        /* <example>true</example> */
        [JsonPropertyName("greek")]
        public bool? Greek { get { return this.GreekOption; } set { this.GreekOption = new(value); } }

        /// <summary>
        /// Used to track the state of Latin
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> LatinOption { get; private set; }

        /// <summary>
        /// Include Latin character substitutions
        /// </summary>
        /// <value>Include Latin character substitutions</value>
        /* <example>true</example> */
        [JsonPropertyName("latin")]
        public bool? Latin { get { return this.LatinOption; } set { this.LatinOption = new(value); } }

        /// <summary>
        /// Used to track the state of MaxSubstitutions
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> MaxSubstitutionsOption { get; private set; }

        /// <summary>
        /// Maximum number of character substitutions per domain
        /// </summary>
        /// <value>Maximum number of character substitutions per domain</value>
        /* <example>2</example> */
        [JsonPropertyName("max_substitutions")]
        public int? MaxSubstitutions { get { return this.MaxSubstitutionsOption; } set { this.MaxSubstitutionsOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class HomoglyphConfig {\n");
            sb.Append("  Cyrillic: ").Append(Cyrillic).Append("\n");
            sb.Append("  Greek: ").Append(Greek).Append("\n");
            sb.Append("  Latin: ").Append(Latin).Append("\n");
            sb.Append("  MaxSubstitutions: ").Append(MaxSubstitutions).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // MaxSubstitutions (int) maximum
            if (this.MaxSubstitutionsOption.IsSet && this.MaxSubstitutionsOption.Value > (int)5)
            {
                yield return new ValidationResult("Invalid value for MaxSubstitutions, must be a value less than or equal to 5.", new [] { "MaxSubstitutions" });
            }

            // MaxSubstitutions (int) minimum
            if (this.MaxSubstitutionsOption.IsSet && this.MaxSubstitutionsOption.Value < (int)1)
            {
                yield return new ValidationResult("Invalid value for MaxSubstitutions, must be a value greater than or equal to 1.", new [] { "MaxSubstitutions" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="HomoglyphConfig" />
    /// </summary>
    public class HomoglyphConfigJsonConverter : JsonConverter<HomoglyphConfig>
    {
        /// <summary>
        /// Deserializes json to <see cref="HomoglyphConfig" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override HomoglyphConfig Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<bool?> cyrillic = default;
            Option<bool?> greek = default;
            Option<bool?> latin = default;
            Option<int?> maxSubstitutions = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "cyrillic":
                            cyrillic = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "greek":
                            greek = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "latin":
                            latin = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "max_substitutions":
                            maxSubstitutions = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (cyrillic.IsSet && cyrillic.Value == null)
                throw new ArgumentNullException(nameof(cyrillic), "Property is not nullable for class HomoglyphConfig.");

            if (greek.IsSet && greek.Value == null)
                throw new ArgumentNullException(nameof(greek), "Property is not nullable for class HomoglyphConfig.");

            if (latin.IsSet && latin.Value == null)
                throw new ArgumentNullException(nameof(latin), "Property is not nullable for class HomoglyphConfig.");

            if (maxSubstitutions.IsSet && maxSubstitutions.Value == null)
                throw new ArgumentNullException(nameof(maxSubstitutions), "Property is not nullable for class HomoglyphConfig.");

            return new HomoglyphConfig(cyrillic, greek, latin, maxSubstitutions);
        }

        /// <summary>
        /// Serializes a <see cref="HomoglyphConfig" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="homoglyphConfig"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, HomoglyphConfig homoglyphConfig, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, homoglyphConfig, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="HomoglyphConfig" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="homoglyphConfig"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, HomoglyphConfig homoglyphConfig, JsonSerializerOptions jsonSerializerOptions)
        {
            if (homoglyphConfig.CyrillicOption.IsSet)
                writer.WriteBoolean("cyrillic", homoglyphConfig.CyrillicOption.Value.Value);

            if (homoglyphConfig.GreekOption.IsSet)
                writer.WriteBoolean("greek", homoglyphConfig.GreekOption.Value.Value);

            if (homoglyphConfig.LatinOption.IsSet)
                writer.WriteBoolean("latin", homoglyphConfig.LatinOption.Value.Value);

            if (homoglyphConfig.MaxSubstitutionsOption.IsSet)
                writer.WriteNumber("max_substitutions", homoglyphConfig.MaxSubstitutionsOption.Value.Value);
        }
    }
}
