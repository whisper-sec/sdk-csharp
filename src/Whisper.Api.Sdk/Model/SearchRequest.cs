// <auto-generated>
/*
 * Whisper Security API
 *
 * # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -|- -- -- -- -- -- --| | Indicators (`/v1/indicators/_*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/_*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/_*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/_*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/_*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/_*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/_*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@whisper.security
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Whisper.Api.Sdk.Client;

namespace Whisper.Api.Sdk.Model
{
    /// <summary>
    /// Search query for finding domains matching WHOIS registration criteria.  **Query Modes:** 1. **Field-based (recommended):** Specify individual fields like &#x60;registrantCompany&#x60;, &#x60;tld&#x60;, etc. 2. **Query string:** Use &#x60;query&#x60; field with &#x60;field:value&#x60; syntax for compatibility.  Multiple criteria are combined with AND logic. Results are paginated with a maximum of 100 results per page.  **Use Cases:** - Threat hunting: Find domains registered by known malicious actors - Brand protection: Monitor for domains similar to your brand - Infrastructure discovery: Map domains sharing registrants or nameservers - Investigation: Track domains created on specific dates 
    /// </summary>
    public partial class SearchRequest : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SearchRequest" /> class.
        /// </summary>
        /// <param name="effectivePage">effectivePage</param>
        /// <param name="query">Search query using field:value syntax (alternative to individual field parameters). If individual field parameters are provided, they take precedence.  **Supported Syntax:** - Single field: &#x60;registrantCompany:Google&#x60; - Multiple fields: &#x60;registrantCompany:Google registrantCountry:US&#x60;  **Note:** For new integrations, prefer using individual field parameters instead of query syntax. </param>
        /// <param name="field">Field to search in when using simple query mode. Use with &#x60;query&#x60; parameter.</param>
        /// <param name="tld">Top-Level Domain to filter by (exact match). Examples: com, org, net, io</param>
        /// <param name="registrarName">Domain registrar name to filter by (exact match)</param>
        /// <param name="registrarIanaId">IANA registrar ID to filter by (exact match)</param>
        /// <param name="registrantName">Registrant name to search for (text search, partial match)</param>
        /// <param name="registrantCompany">Registrant company/organization to search for (text search, partial match)</param>
        /// <param name="registrantEmail">Registrant email to search for (text search). Supports wildcards like *@example.com</param>
        /// <param name="registrantPhone">Registrant phone number to search for (text search)</param>
        /// <param name="registrantCountry">Registrant country code to filter by (2-letter ISO code)</param>
        /// <param name="registrantCity">Registrant city to search for (text search)</param>
        /// <param name="nameServer">Name server hostname to search for (text search)</param>
        /// <param name="domainStatus">Domain status flag to search for (text search). E.g., clientTransferProhibited</param>
        /// <param name="createdDate">Domain creation date to filter by (exact match, format: YYYY-MM-DD)</param>
        /// <param name="updatedDate">Domain last update date to filter by (exact match, format: YYYY-MM-DD)</param>
        /// <param name="expiryDate">Domain expiry date to filter by (exact match, format: YYYY-MM-DD)</param>
        /// <param name="limit">Maximum number of results to return per page (max 100 for WHOIS searches) (default to 100)</param>
        /// <param name="page">Page number for pagination (0-indexed). Alternative to offset. (default to 0)</param>
        /// <param name="offset">Number of results to skip for pagination. Converted to page internally. (default to 0)</param>
        [JsonConstructor]
        public SearchRequest(Option<int?> effectivePage = default, Option<string> query = default, Option<FieldEnum?> field = default, Option<string> tld = default, Option<string> registrarName = default, Option<string> registrarIanaId = default, Option<string> registrantName = default, Option<string> registrantCompany = default, Option<string> registrantEmail = default, Option<string> registrantPhone = default, Option<string> registrantCountry = default, Option<string> registrantCity = default, Option<string> nameServer = default, Option<string> domainStatus = default, Option<string> createdDate = default, Option<string> updatedDate = default, Option<string> expiryDate = default, Option<int?> limit = default, Option<int?> page = default, Option<int?> offset = default)
        {
            EffectivePageOption = effectivePage;
            QueryOption = query;
            FieldOption = field;
            TldOption = tld;
            RegistrarNameOption = registrarName;
            RegistrarIanaIdOption = registrarIanaId;
            RegistrantNameOption = registrantName;
            RegistrantCompanyOption = registrantCompany;
            RegistrantEmailOption = registrantEmail;
            RegistrantPhoneOption = registrantPhone;
            RegistrantCountryOption = registrantCountry;
            RegistrantCityOption = registrantCity;
            NameServerOption = nameServer;
            DomainStatusOption = domainStatus;
            CreatedDateOption = createdDate;
            UpdatedDateOption = updatedDate;
            ExpiryDateOption = expiryDate;
            LimitOption = limit;
            PageOption = page;
            OffsetOption = offset;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Field to search in when using simple query mode. Use with &#x60;query&#x60; parameter.
        /// </summary>
        /// <value>Field to search in when using simple query mode. Use with &#x60;query&#x60; parameter.</value>
        public enum FieldEnum
        {
            /// <summary>
            /// Enum RegistrantName for value: registrantName
            /// </summary>
            RegistrantName = 1,

            /// <summary>
            /// Enum RegistrantCompany for value: registrantCompany
            /// </summary>
            RegistrantCompany = 2,

            /// <summary>
            /// Enum RegistrantEmail for value: registrantEmail
            /// </summary>
            RegistrantEmail = 3,

            /// <summary>
            /// Enum RegistrantPhone for value: registrantPhone
            /// </summary>
            RegistrantPhone = 4,

            /// <summary>
            /// Enum RegistrantCountry for value: registrantCountry
            /// </summary>
            RegistrantCountry = 5,

            /// <summary>
            /// Enum RegistrantCity for value: registrantCity
            /// </summary>
            RegistrantCity = 6,

            /// <summary>
            /// Enum NameServer for value: nameServer
            /// </summary>
            NameServer = 7,

            /// <summary>
            /// Enum RegistrarName for value: registrarName
            /// </summary>
            RegistrarName = 8,

            /// <summary>
            /// Enum RegistrarIanaId for value: registrarIanaId
            /// </summary>
            RegistrarIanaId = 9,

            /// <summary>
            /// Enum Tld for value: tld
            /// </summary>
            Tld = 10,

            /// <summary>
            /// Enum DomainStatus for value: domainStatus
            /// </summary>
            DomainStatus = 11,

            /// <summary>
            /// Enum CreatedDate for value: createdDate
            /// </summary>
            CreatedDate = 12,

            /// <summary>
            /// Enum UpdatedDate for value: updatedDate
            /// </summary>
            UpdatedDate = 13,

            /// <summary>
            /// Enum ExpiryDate for value: expiryDate
            /// </summary>
            ExpiryDate = 14
        }

        /// <summary>
        /// Returns a <see cref="FieldEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static FieldEnum FieldEnumFromString(string value)
        {
            if (value.Equals("registrantName"))
                return FieldEnum.RegistrantName;

            if (value.Equals("registrantCompany"))
                return FieldEnum.RegistrantCompany;

            if (value.Equals("registrantEmail"))
                return FieldEnum.RegistrantEmail;

            if (value.Equals("registrantPhone"))
                return FieldEnum.RegistrantPhone;

            if (value.Equals("registrantCountry"))
                return FieldEnum.RegistrantCountry;

            if (value.Equals("registrantCity"))
                return FieldEnum.RegistrantCity;

            if (value.Equals("nameServer"))
                return FieldEnum.NameServer;

            if (value.Equals("registrarName"))
                return FieldEnum.RegistrarName;

            if (value.Equals("registrarIanaId"))
                return FieldEnum.RegistrarIanaId;

            if (value.Equals("tld"))
                return FieldEnum.Tld;

            if (value.Equals("domainStatus"))
                return FieldEnum.DomainStatus;

            if (value.Equals("createdDate"))
                return FieldEnum.CreatedDate;

            if (value.Equals("updatedDate"))
                return FieldEnum.UpdatedDate;

            if (value.Equals("expiryDate"))
                return FieldEnum.ExpiryDate;

            throw new NotImplementedException($"Could not convert value to type FieldEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="FieldEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static FieldEnum? FieldEnumFromStringOrDefault(string value)
        {
            if (value.Equals("registrantName"))
                return FieldEnum.RegistrantName;

            if (value.Equals("registrantCompany"))
                return FieldEnum.RegistrantCompany;

            if (value.Equals("registrantEmail"))
                return FieldEnum.RegistrantEmail;

            if (value.Equals("registrantPhone"))
                return FieldEnum.RegistrantPhone;

            if (value.Equals("registrantCountry"))
                return FieldEnum.RegistrantCountry;

            if (value.Equals("registrantCity"))
                return FieldEnum.RegistrantCity;

            if (value.Equals("nameServer"))
                return FieldEnum.NameServer;

            if (value.Equals("registrarName"))
                return FieldEnum.RegistrarName;

            if (value.Equals("registrarIanaId"))
                return FieldEnum.RegistrarIanaId;

            if (value.Equals("tld"))
                return FieldEnum.Tld;

            if (value.Equals("domainStatus"))
                return FieldEnum.DomainStatus;

            if (value.Equals("createdDate"))
                return FieldEnum.CreatedDate;

            if (value.Equals("updatedDate"))
                return FieldEnum.UpdatedDate;

            if (value.Equals("expiryDate"))
                return FieldEnum.ExpiryDate;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="FieldEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string FieldEnumToJsonValue(FieldEnum? value)
        {
            if (value == FieldEnum.RegistrantName)
                return "registrantName";

            if (value == FieldEnum.RegistrantCompany)
                return "registrantCompany";

            if (value == FieldEnum.RegistrantEmail)
                return "registrantEmail";

            if (value == FieldEnum.RegistrantPhone)
                return "registrantPhone";

            if (value == FieldEnum.RegistrantCountry)
                return "registrantCountry";

            if (value == FieldEnum.RegistrantCity)
                return "registrantCity";

            if (value == FieldEnum.NameServer)
                return "nameServer";

            if (value == FieldEnum.RegistrarName)
                return "registrarName";

            if (value == FieldEnum.RegistrarIanaId)
                return "registrarIanaId";

            if (value == FieldEnum.Tld)
                return "tld";

            if (value == FieldEnum.DomainStatus)
                return "domainStatus";

            if (value == FieldEnum.CreatedDate)
                return "createdDate";

            if (value == FieldEnum.UpdatedDate)
                return "updatedDate";

            if (value == FieldEnum.ExpiryDate)
                return "expiryDate";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of Field
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<FieldEnum?> FieldOption { get; private set; }

        /// <summary>
        /// Field to search in when using simple query mode. Use with &#x60;query&#x60; parameter.
        /// </summary>
        /// <value>Field to search in when using simple query mode. Use with &#x60;query&#x60; parameter.</value>
        /* <example>registrantCompany</example> */
        [JsonPropertyName("field")]
        public FieldEnum? Field { get { return this.FieldOption; } set { this.FieldOption = new(value); } }

        /// <summary>
        /// Used to track the state of EffectivePage
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> EffectivePageOption { get; private set; }

        /// <summary>
        /// Gets or Sets EffectivePage
        /// </summary>
        [JsonPropertyName("effectivePage")]
        public int? EffectivePage { get { return this.EffectivePageOption; } set { this.EffectivePageOption = new(value); } }

        /// <summary>
        /// Used to track the state of Query
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> QueryOption { get; private set; }

        /// <summary>
        /// Search query using field:value syntax (alternative to individual field parameters). If individual field parameters are provided, they take precedence.  **Supported Syntax:** - Single field: &#x60;registrantCompany:Google&#x60; - Multiple fields: &#x60;registrantCompany:Google registrantCountry:US&#x60;  **Note:** For new integrations, prefer using individual field parameters instead of query syntax. 
        /// </summary>
        /// <value>Search query using field:value syntax (alternative to individual field parameters). If individual field parameters are provided, they take precedence.  **Supported Syntax:** - Single field: &#x60;registrantCompany:Google&#x60; - Multiple fields: &#x60;registrantCompany:Google registrantCountry:US&#x60;  **Note:** For new integrations, prefer using individual field parameters instead of query syntax. </value>
        /* <example>registrantCompany:Google</example> */
        [JsonPropertyName("query")]
        public string Query { get { return this.QueryOption; } set { this.QueryOption = new(value); } }

        /// <summary>
        /// Used to track the state of Tld
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> TldOption { get; private set; }

        /// <summary>
        /// Top-Level Domain to filter by (exact match). Examples: com, org, net, io
        /// </summary>
        /// <value>Top-Level Domain to filter by (exact match). Examples: com, org, net, io</value>
        /* <example>com</example> */
        [JsonPropertyName("tld")]
        public string Tld { get { return this.TldOption; } set { this.TldOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrarName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RegistrarNameOption { get; private set; }

        /// <summary>
        /// Domain registrar name to filter by (exact match)
        /// </summary>
        /// <value>Domain registrar name to filter by (exact match)</value>
        /* <example>GoDaddy.com, LLC</example> */
        [JsonPropertyName("registrarName")]
        public string RegistrarName { get { return this.RegistrarNameOption; } set { this.RegistrarNameOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrarIanaId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RegistrarIanaIdOption { get; private set; }

        /// <summary>
        /// IANA registrar ID to filter by (exact match)
        /// </summary>
        /// <value>IANA registrar ID to filter by (exact match)</value>
        /* <example>146</example> */
        [JsonPropertyName("registrarIanaId")]
        public string RegistrarIanaId { get { return this.RegistrarIanaIdOption; } set { this.RegistrarIanaIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrantName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RegistrantNameOption { get; private set; }

        /// <summary>
        /// Registrant name to search for (text search, partial match)
        /// </summary>
        /// <value>Registrant name to search for (text search, partial match)</value>
        /* <example>John Doe</example> */
        [JsonPropertyName("registrantName")]
        public string RegistrantName { get { return this.RegistrantNameOption; } set { this.RegistrantNameOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrantCompany
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RegistrantCompanyOption { get; private set; }

        /// <summary>
        /// Registrant company/organization to search for (text search, partial match)
        /// </summary>
        /// <value>Registrant company/organization to search for (text search, partial match)</value>
        /* <example>Google LLC</example> */
        [JsonPropertyName("registrantCompany")]
        public string RegistrantCompany { get { return this.RegistrantCompanyOption; } set { this.RegistrantCompanyOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrantEmail
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RegistrantEmailOption { get; private set; }

        /// <summary>
        /// Registrant email to search for (text search). Supports wildcards like *@example.com
        /// </summary>
        /// <value>Registrant email to search for (text search). Supports wildcards like *@example.com</value>
        /* <example>admin@example.com</example> */
        [JsonPropertyName("registrantEmail")]
        public string RegistrantEmail { get { return this.RegistrantEmailOption; } set { this.RegistrantEmailOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrantPhone
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RegistrantPhoneOption { get; private set; }

        /// <summary>
        /// Registrant phone number to search for (text search)
        /// </summary>
        /// <value>Registrant phone number to search for (text search)</value>
        /* <example>+1.6502530000</example> */
        [JsonPropertyName("registrantPhone")]
        public string RegistrantPhone { get { return this.RegistrantPhoneOption; } set { this.RegistrantPhoneOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrantCountry
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RegistrantCountryOption { get; private set; }

        /// <summary>
        /// Registrant country code to filter by (2-letter ISO code)
        /// </summary>
        /// <value>Registrant country code to filter by (2-letter ISO code)</value>
        /* <example>US</example> */
        [JsonPropertyName("registrantCountry")]
        public string RegistrantCountry { get { return this.RegistrantCountryOption; } set { this.RegistrantCountryOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrantCity
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> RegistrantCityOption { get; private set; }

        /// <summary>
        /// Registrant city to search for (text search)
        /// </summary>
        /// <value>Registrant city to search for (text search)</value>
        /* <example>Mountain View</example> */
        [JsonPropertyName("registrantCity")]
        public string RegistrantCity { get { return this.RegistrantCityOption; } set { this.RegistrantCityOption = new(value); } }

        /// <summary>
        /// Used to track the state of NameServer
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> NameServerOption { get; private set; }

        /// <summary>
        /// Name server hostname to search for (text search)
        /// </summary>
        /// <value>Name server hostname to search for (text search)</value>
        /* <example>ns1.google.com</example> */
        [JsonPropertyName("nameServer")]
        public string NameServer { get { return this.NameServerOption; } set { this.NameServerOption = new(value); } }

        /// <summary>
        /// Used to track the state of DomainStatus
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> DomainStatusOption { get; private set; }

        /// <summary>
        /// Domain status flag to search for (text search). E.g., clientTransferProhibited
        /// </summary>
        /// <value>Domain status flag to search for (text search). E.g., clientTransferProhibited</value>
        /* <example>clientTransferProhibited</example> */
        [JsonPropertyName("domainStatus")]
        public string DomainStatus { get { return this.DomainStatusOption; } set { this.DomainStatusOption = new(value); } }

        /// <summary>
        /// Used to track the state of CreatedDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> CreatedDateOption { get; private set; }

        /// <summary>
        /// Domain creation date to filter by (exact match, format: YYYY-MM-DD)
        /// </summary>
        /// <value>Domain creation date to filter by (exact match, format: YYYY-MM-DD)</value>
        /* <example>2024-01-15</example> */
        [JsonPropertyName("createdDate")]
        public string CreatedDate { get { return this.CreatedDateOption; } set { this.CreatedDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of UpdatedDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> UpdatedDateOption { get; private set; }

        /// <summary>
        /// Domain last update date to filter by (exact match, format: YYYY-MM-DD)
        /// </summary>
        /// <value>Domain last update date to filter by (exact match, format: YYYY-MM-DD)</value>
        /* <example>2024-06-01</example> */
        [JsonPropertyName("updatedDate")]
        public string UpdatedDate { get { return this.UpdatedDateOption; } set { this.UpdatedDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of ExpiryDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> ExpiryDateOption { get; private set; }

        /// <summary>
        /// Domain expiry date to filter by (exact match, format: YYYY-MM-DD)
        /// </summary>
        /// <value>Domain expiry date to filter by (exact match, format: YYYY-MM-DD)</value>
        /* <example>2025-01-15</example> */
        [JsonPropertyName("expiryDate")]
        public string ExpiryDate { get { return this.ExpiryDateOption; } set { this.ExpiryDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of Limit
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> LimitOption { get; private set; }

        /// <summary>
        /// Maximum number of results to return per page (max 100 for WHOIS searches)
        /// </summary>
        /// <value>Maximum number of results to return per page (max 100 for WHOIS searches)</value>
        /* <example>100</example> */
        [JsonPropertyName("limit")]
        public int? Limit { get { return this.LimitOption; } set { this.LimitOption = new(value); } }

        /// <summary>
        /// Used to track the state of Page
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> PageOption { get; private set; }

        /// <summary>
        /// Page number for pagination (0-indexed). Alternative to offset.
        /// </summary>
        /// <value>Page number for pagination (0-indexed). Alternative to offset.</value>
        /* <example>0</example> */
        [JsonPropertyName("page")]
        public int? Page { get { return this.PageOption; } set { this.PageOption = new(value); } }

        /// <summary>
        /// Used to track the state of Offset
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> OffsetOption { get; private set; }

        /// <summary>
        /// Number of results to skip for pagination. Converted to page internally.
        /// </summary>
        /// <value>Number of results to skip for pagination. Converted to page internally.</value>
        /* <example>0</example> */
        [JsonPropertyName("offset")]
        public int? Offset { get { return this.OffsetOption; } set { this.OffsetOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class SearchRequest {\n");
            sb.Append("  EffectivePage: ").Append(EffectivePage).Append("\n");
            sb.Append("  Query: ").Append(Query).Append("\n");
            sb.Append("  Field: ").Append(Field).Append("\n");
            sb.Append("  Tld: ").Append(Tld).Append("\n");
            sb.Append("  RegistrarName: ").Append(RegistrarName).Append("\n");
            sb.Append("  RegistrarIanaId: ").Append(RegistrarIanaId).Append("\n");
            sb.Append("  RegistrantName: ").Append(RegistrantName).Append("\n");
            sb.Append("  RegistrantCompany: ").Append(RegistrantCompany).Append("\n");
            sb.Append("  RegistrantEmail: ").Append(RegistrantEmail).Append("\n");
            sb.Append("  RegistrantPhone: ").Append(RegistrantPhone).Append("\n");
            sb.Append("  RegistrantCountry: ").Append(RegistrantCountry).Append("\n");
            sb.Append("  RegistrantCity: ").Append(RegistrantCity).Append("\n");
            sb.Append("  NameServer: ").Append(NameServer).Append("\n");
            sb.Append("  DomainStatus: ").Append(DomainStatus).Append("\n");
            sb.Append("  CreatedDate: ").Append(CreatedDate).Append("\n");
            sb.Append("  UpdatedDate: ").Append(UpdatedDate).Append("\n");
            sb.Append("  ExpiryDate: ").Append(ExpiryDate).Append("\n");
            sb.Append("  Limit: ").Append(Limit).Append("\n");
            sb.Append("  Page: ").Append(Page).Append("\n");
            sb.Append("  Offset: ").Append(Offset).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            if (this.CreatedDateOption.Value != null) {
                // CreatedDate (string) pattern
                Regex regexCreatedDate = new Regex(@"^\d{4}-\d{2}-\d{2}$", RegexOptions.CultureInvariant);

                if (this.CreatedDateOption.Value != null &&!regexCreatedDate.Match(this.CreatedDateOption.Value).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CreatedDate, must match a pattern of " + regexCreatedDate, new [] { "CreatedDate" });
                }
            }

            if (this.UpdatedDateOption.Value != null) {
                // UpdatedDate (string) pattern
                Regex regexUpdatedDate = new Regex(@"^\d{4}-\d{2}-\d{2}$", RegexOptions.CultureInvariant);

                if (this.UpdatedDateOption.Value != null &&!regexUpdatedDate.Match(this.UpdatedDateOption.Value).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UpdatedDate, must match a pattern of " + regexUpdatedDate, new [] { "UpdatedDate" });
                }
            }

            if (this.ExpiryDateOption.Value != null) {
                // ExpiryDate (string) pattern
                Regex regexExpiryDate = new Regex(@"^\d{4}-\d{2}-\d{2}$", RegexOptions.CultureInvariant);

                if (this.ExpiryDateOption.Value != null &&!regexExpiryDate.Match(this.ExpiryDateOption.Value).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ExpiryDate, must match a pattern of " + regexExpiryDate, new [] { "ExpiryDate" });
                }
            }

            // Limit (int) maximum
            if (this.LimitOption.IsSet && this.LimitOption.Value > (int)100)
            {
                yield return new ValidationResult("Invalid value for Limit, must be a value less than or equal to 100.", new [] { "Limit" });
            }

            // Limit (int) minimum
            if (this.LimitOption.IsSet && this.LimitOption.Value < (int)1)
            {
                yield return new ValidationResult("Invalid value for Limit, must be a value greater than or equal to 1.", new [] { "Limit" });
            }

            // Page (int) minimum
            if (this.PageOption.IsSet && this.PageOption.Value < (int)0)
            {
                yield return new ValidationResult("Invalid value for Page, must be a value greater than or equal to 0.", new [] { "Page" });
            }

            // Offset (int) minimum
            if (this.OffsetOption.IsSet && this.OffsetOption.Value < (int)0)
            {
                yield return new ValidationResult("Invalid value for Offset, must be a value greater than or equal to 0.", new [] { "Offset" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="SearchRequest" />
    /// </summary>
    public class SearchRequestJsonConverter : JsonConverter<SearchRequest>
    {
        /// <summary>
        /// Deserializes json to <see cref="SearchRequest" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override SearchRequest Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<int?> effectivePage = default;
            Option<string> query = default;
            Option<SearchRequest.FieldEnum?> field = default;
            Option<string> tld = default;
            Option<string> registrarName = default;
            Option<string> registrarIanaId = default;
            Option<string> registrantName = default;
            Option<string> registrantCompany = default;
            Option<string> registrantEmail = default;
            Option<string> registrantPhone = default;
            Option<string> registrantCountry = default;
            Option<string> registrantCity = default;
            Option<string> nameServer = default;
            Option<string> domainStatus = default;
            Option<string> createdDate = default;
            Option<string> updatedDate = default;
            Option<string> expiryDate = default;
            Option<int?> limit = default;
            Option<int?> page = default;
            Option<int?> offset = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "effectivePage":
                            effectivePage = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "query":
                            query = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "field":
                            string fieldRawValue = utf8JsonReader.GetString();
                            if (fieldRawValue != null)
                                field = new Option<SearchRequest.FieldEnum?>(SearchRequest.FieldEnumFromStringOrDefault(fieldRawValue));
                            break;
                        case "tld":
                            tld = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "registrarName":
                            registrarName = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "registrarIanaId":
                            registrarIanaId = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "registrantName":
                            registrantName = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "registrantCompany":
                            registrantCompany = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "registrantEmail":
                            registrantEmail = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "registrantPhone":
                            registrantPhone = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "registrantCountry":
                            registrantCountry = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "registrantCity":
                            registrantCity = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "nameServer":
                            nameServer = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "domainStatus":
                            domainStatus = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "createdDate":
                            createdDate = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "updatedDate":
                            updatedDate = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "expiryDate":
                            expiryDate = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "limit":
                            limit = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "page":
                            page = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "offset":
                            offset = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (effectivePage.IsSet && effectivePage.Value == null)
                throw new ArgumentNullException(nameof(effectivePage), "Property is not nullable for class SearchRequest.");

            if (query.IsSet && query.Value == null)
                throw new ArgumentNullException(nameof(query), "Property is not nullable for class SearchRequest.");

            if (field.IsSet && field.Value == null)
                throw new ArgumentNullException(nameof(field), "Property is not nullable for class SearchRequest.");

            if (tld.IsSet && tld.Value == null)
                throw new ArgumentNullException(nameof(tld), "Property is not nullable for class SearchRequest.");

            if (registrarName.IsSet && registrarName.Value == null)
                throw new ArgumentNullException(nameof(registrarName), "Property is not nullable for class SearchRequest.");

            if (registrarIanaId.IsSet && registrarIanaId.Value == null)
                throw new ArgumentNullException(nameof(registrarIanaId), "Property is not nullable for class SearchRequest.");

            if (registrantName.IsSet && registrantName.Value == null)
                throw new ArgumentNullException(nameof(registrantName), "Property is not nullable for class SearchRequest.");

            if (registrantCompany.IsSet && registrantCompany.Value == null)
                throw new ArgumentNullException(nameof(registrantCompany), "Property is not nullable for class SearchRequest.");

            if (registrantEmail.IsSet && registrantEmail.Value == null)
                throw new ArgumentNullException(nameof(registrantEmail), "Property is not nullable for class SearchRequest.");

            if (registrantPhone.IsSet && registrantPhone.Value == null)
                throw new ArgumentNullException(nameof(registrantPhone), "Property is not nullable for class SearchRequest.");

            if (registrantCountry.IsSet && registrantCountry.Value == null)
                throw new ArgumentNullException(nameof(registrantCountry), "Property is not nullable for class SearchRequest.");

            if (registrantCity.IsSet && registrantCity.Value == null)
                throw new ArgumentNullException(nameof(registrantCity), "Property is not nullable for class SearchRequest.");

            if (nameServer.IsSet && nameServer.Value == null)
                throw new ArgumentNullException(nameof(nameServer), "Property is not nullable for class SearchRequest.");

            if (domainStatus.IsSet && domainStatus.Value == null)
                throw new ArgumentNullException(nameof(domainStatus), "Property is not nullable for class SearchRequest.");

            if (createdDate.IsSet && createdDate.Value == null)
                throw new ArgumentNullException(nameof(createdDate), "Property is not nullable for class SearchRequest.");

            if (updatedDate.IsSet && updatedDate.Value == null)
                throw new ArgumentNullException(nameof(updatedDate), "Property is not nullable for class SearchRequest.");

            if (expiryDate.IsSet && expiryDate.Value == null)
                throw new ArgumentNullException(nameof(expiryDate), "Property is not nullable for class SearchRequest.");

            if (limit.IsSet && limit.Value == null)
                throw new ArgumentNullException(nameof(limit), "Property is not nullable for class SearchRequest.");

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page), "Property is not nullable for class SearchRequest.");

            if (offset.IsSet && offset.Value == null)
                throw new ArgumentNullException(nameof(offset), "Property is not nullable for class SearchRequest.");

            return new SearchRequest(effectivePage, query, field, tld, registrarName, registrarIanaId, registrantName, registrantCompany, registrantEmail, registrantPhone, registrantCountry, registrantCity, nameServer, domainStatus, createdDate, updatedDate, expiryDate, limit, page, offset);
        }

        /// <summary>
        /// Serializes a <see cref="SearchRequest" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="searchRequest"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, SearchRequest searchRequest, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, searchRequest, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="SearchRequest" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="searchRequest"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, SearchRequest searchRequest, JsonSerializerOptions jsonSerializerOptions)
        {
            if (searchRequest.QueryOption.IsSet && searchRequest.Query == null)
                throw new ArgumentNullException(nameof(searchRequest.Query), "Property is required for class SearchRequest.");

            if (searchRequest.TldOption.IsSet && searchRequest.Tld == null)
                throw new ArgumentNullException(nameof(searchRequest.Tld), "Property is required for class SearchRequest.");

            if (searchRequest.RegistrarNameOption.IsSet && searchRequest.RegistrarName == null)
                throw new ArgumentNullException(nameof(searchRequest.RegistrarName), "Property is required for class SearchRequest.");

            if (searchRequest.RegistrarIanaIdOption.IsSet && searchRequest.RegistrarIanaId == null)
                throw new ArgumentNullException(nameof(searchRequest.RegistrarIanaId), "Property is required for class SearchRequest.");

            if (searchRequest.RegistrantNameOption.IsSet && searchRequest.RegistrantName == null)
                throw new ArgumentNullException(nameof(searchRequest.RegistrantName), "Property is required for class SearchRequest.");

            if (searchRequest.RegistrantCompanyOption.IsSet && searchRequest.RegistrantCompany == null)
                throw new ArgumentNullException(nameof(searchRequest.RegistrantCompany), "Property is required for class SearchRequest.");

            if (searchRequest.RegistrantEmailOption.IsSet && searchRequest.RegistrantEmail == null)
                throw new ArgumentNullException(nameof(searchRequest.RegistrantEmail), "Property is required for class SearchRequest.");

            if (searchRequest.RegistrantPhoneOption.IsSet && searchRequest.RegistrantPhone == null)
                throw new ArgumentNullException(nameof(searchRequest.RegistrantPhone), "Property is required for class SearchRequest.");

            if (searchRequest.RegistrantCountryOption.IsSet && searchRequest.RegistrantCountry == null)
                throw new ArgumentNullException(nameof(searchRequest.RegistrantCountry), "Property is required for class SearchRequest.");

            if (searchRequest.RegistrantCityOption.IsSet && searchRequest.RegistrantCity == null)
                throw new ArgumentNullException(nameof(searchRequest.RegistrantCity), "Property is required for class SearchRequest.");

            if (searchRequest.NameServerOption.IsSet && searchRequest.NameServer == null)
                throw new ArgumentNullException(nameof(searchRequest.NameServer), "Property is required for class SearchRequest.");

            if (searchRequest.DomainStatusOption.IsSet && searchRequest.DomainStatus == null)
                throw new ArgumentNullException(nameof(searchRequest.DomainStatus), "Property is required for class SearchRequest.");

            if (searchRequest.CreatedDateOption.IsSet && searchRequest.CreatedDate == null)
                throw new ArgumentNullException(nameof(searchRequest.CreatedDate), "Property is required for class SearchRequest.");

            if (searchRequest.UpdatedDateOption.IsSet && searchRequest.UpdatedDate == null)
                throw new ArgumentNullException(nameof(searchRequest.UpdatedDate), "Property is required for class SearchRequest.");

            if (searchRequest.ExpiryDateOption.IsSet && searchRequest.ExpiryDate == null)
                throw new ArgumentNullException(nameof(searchRequest.ExpiryDate), "Property is required for class SearchRequest.");

            if (searchRequest.EffectivePageOption.IsSet)
                writer.WriteNumber("effectivePage", searchRequest.EffectivePageOption.Value.Value);

            if (searchRequest.QueryOption.IsSet)
                writer.WriteString("query", searchRequest.Query);

            var fieldRawValue = SearchRequest.FieldEnumToJsonValue(searchRequest.FieldOption.Value.Value);
            writer.WriteString("field", fieldRawValue);
            if (searchRequest.TldOption.IsSet)
                writer.WriteString("tld", searchRequest.Tld);

            if (searchRequest.RegistrarNameOption.IsSet)
                writer.WriteString("registrarName", searchRequest.RegistrarName);

            if (searchRequest.RegistrarIanaIdOption.IsSet)
                writer.WriteString("registrarIanaId", searchRequest.RegistrarIanaId);

            if (searchRequest.RegistrantNameOption.IsSet)
                writer.WriteString("registrantName", searchRequest.RegistrantName);

            if (searchRequest.RegistrantCompanyOption.IsSet)
                writer.WriteString("registrantCompany", searchRequest.RegistrantCompany);

            if (searchRequest.RegistrantEmailOption.IsSet)
                writer.WriteString("registrantEmail", searchRequest.RegistrantEmail);

            if (searchRequest.RegistrantPhoneOption.IsSet)
                writer.WriteString("registrantPhone", searchRequest.RegistrantPhone);

            if (searchRequest.RegistrantCountryOption.IsSet)
                writer.WriteString("registrantCountry", searchRequest.RegistrantCountry);

            if (searchRequest.RegistrantCityOption.IsSet)
                writer.WriteString("registrantCity", searchRequest.RegistrantCity);

            if (searchRequest.NameServerOption.IsSet)
                writer.WriteString("nameServer", searchRequest.NameServer);

            if (searchRequest.DomainStatusOption.IsSet)
                writer.WriteString("domainStatus", searchRequest.DomainStatus);

            if (searchRequest.CreatedDateOption.IsSet)
                writer.WriteString("createdDate", searchRequest.CreatedDate);

            if (searchRequest.UpdatedDateOption.IsSet)
                writer.WriteString("updatedDate", searchRequest.UpdatedDate);

            if (searchRequest.ExpiryDateOption.IsSet)
                writer.WriteString("expiryDate", searchRequest.ExpiryDate);

            if (searchRequest.LimitOption.IsSet)
                writer.WriteNumber("limit", searchRequest.LimitOption.Value.Value);

            if (searchRequest.PageOption.IsSet)
                writer.WriteNumber("page", searchRequest.PageOption.Value.Value);

            if (searchRequest.OffsetOption.IsSet)
                writer.WriteNumber("offset", searchRequest.OffsetOption.Value.Value);
        }
    }
}
