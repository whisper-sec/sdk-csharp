// <auto-generated>
/*
 * Whisper Security API
 *
 * # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -|- -- -- -- -- -- --| | Indicators (`/v1/indicators/_*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/_*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/_*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/_*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/_*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/_*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/_*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@whisper.security
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Whisper.Api.Sdk.Client;
using Whisper.Api.Sdk.Model;
using System.Diagnostics.CodeAnalysis;

namespace Whisper.Api.Sdk.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IGraphDatabaseApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        GraphDatabaseApiEvents Events { get; }

        /// <summary>
        /// Execute Cypher Query
        /// </summary>
        /// <remarks>
        /// Execute a read-only Cypher query against the FalkorDB graph database.  **Security:** Only read operations (MATCH, RETURN) are allowed. Write operations are blocked.  **Example Queries:** &#x60;&#x60;&#x60;cypher // Find all IPs for a domain MATCH (d:DomainName {name: $domain})-[:hasIP]-&gt;(ip:A_ADDRESS) RETURN ip.name AS ip  // Find domains on blocklists MATCH (d:DomainName)-[:isListed]-&gt;(l:LIST) RETURN d.name, l.name LIMIT 10  // Get ASN and announced prefixes MATCH (asn:ASN {number: 15169})-[:announces]-&gt;(p:ANNOUNCED_PREFIX_4) RETURN p.name AS prefix &#x60;&#x60;&#x60;  **Performance Tips:** - Always use LIMIT to restrict result size - Use parameters for variable values - Filter early in the query with WHERE clauses 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExecuteCypherQueryApiResponse"/>&gt;</returns>
        Task<IExecuteCypherQueryApiResponse> ExecuteCypherQueryAsync(string authorization, CypherQueryRequest cypherQueryRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Execute Cypher Query
        /// </summary>
        /// <remarks>
        /// Execute a read-only Cypher query against the FalkorDB graph database.  **Security:** Only read operations (MATCH, RETURN) are allowed. Write operations are blocked.  **Example Queries:** &#x60;&#x60;&#x60;cypher // Find all IPs for a domain MATCH (d:DomainName {name: $domain})-[:hasIP]-&gt;(ip:A_ADDRESS) RETURN ip.name AS ip  // Find domains on blocklists MATCH (d:DomainName)-[:isListed]-&gt;(l:LIST) RETURN d.name, l.name LIMIT 10  // Get ASN and announced prefixes MATCH (asn:ASN {number: 15169})-[:announces]-&gt;(p:ANNOUNCED_PREFIX_4) RETURN p.name AS prefix &#x60;&#x60;&#x60;  **Performance Tips:** - Always use LIMIT to restrict result size - Use parameters for variable values - Filter early in the query with WHERE clauses 
        /// </remarks>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExecuteCypherQueryApiResponse"/>&gt;</returns>
        Task<IExecuteCypherQueryApiResponse> ExecuteCypherQueryOrDefaultAsync(string authorization, CypherQueryRequest cypherQueryRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Execute GraphQL Query
        /// </summary>
        /// <remarks>
        /// Execute a GraphQL query against the graph database.  GraphQL provides a type-safe, structured alternative to Cypher for querying the graph data.  **Available Query Operations:** - &#x60;domain(name: String!)&#x60; - Look up domain information - &#x60;ipv4(address: String!)&#x60; - Look up IPv4 address information - &#x60;ipv6(address: String!)&#x60; - Look up IPv6 address information - &#x60;asn(number: Int!)&#x60; - Look up ASN information - &#x60;searchDomains(pattern: String!, limit: Int)&#x60; - Search domains by pattern - &#x60;domainsOnIP(address: String!)&#x60; - Find domains on an IP - &#x60;domainsOnASN(asnNumber: Int!, limit: Int)&#x60; - Find domains on an ASN - &#x60;checkIndicator(indicator: String!)&#x60; - Check if indicator is listed  **Example Query:** &#x60;&#x60;&#x60;graphql {   domain(name: \&quot;google.com\&quot;) {     name     ipAddresses {       address       country { code }     }     nameservers { name }     asns { number }   } } &#x60;&#x60;&#x60;  Use the &#x60;/v1/ops/graph/graphiql&#x60; endpoint for an interactive query explorer with schema documentation. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExecuteGraphQLApiResponse"/>&gt;</returns>
        Task<IExecuteGraphQLApiResponse> ExecuteGraphQLAsync(string authorization, GraphQLRequest graphQLRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Execute GraphQL Query
        /// </summary>
        /// <remarks>
        /// Execute a GraphQL query against the graph database.  GraphQL provides a type-safe, structured alternative to Cypher for querying the graph data.  **Available Query Operations:** - &#x60;domain(name: String!)&#x60; - Look up domain information - &#x60;ipv4(address: String!)&#x60; - Look up IPv4 address information - &#x60;ipv6(address: String!)&#x60; - Look up IPv6 address information - &#x60;asn(number: Int!)&#x60; - Look up ASN information - &#x60;searchDomains(pattern: String!, limit: Int)&#x60; - Search domains by pattern - &#x60;domainsOnIP(address: String!)&#x60; - Find domains on an IP - &#x60;domainsOnASN(asnNumber: Int!, limit: Int)&#x60; - Find domains on an ASN - &#x60;checkIndicator(indicator: String!)&#x60; - Check if indicator is listed  **Example Query:** &#x60;&#x60;&#x60;graphql {   domain(name: \&quot;google.com\&quot;) {     name     ipAddresses {       address       country { code }     }     nameservers { name }     asns { number }   } } &#x60;&#x60;&#x60;  Use the &#x60;/v1/ops/graph/graphiql&#x60; endpoint for an interactive query explorer with schema documentation. 
        /// </remarks>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExecuteGraphQLApiResponse"/>&gt;</returns>
        Task<IExecuteGraphQLApiResponse> ExecuteGraphQLOrDefaultAsync(string authorization, GraphQLRequest graphQLRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// GraphiQL Interactive Explorer
        /// </summary>
        /// <remarks>
        /// Access the GraphiQL interactive query explorer.  GraphiQL provides: - Interactive query editor with syntax highlighting - Auto-complete for types and fields - Schema documentation browser - Query history  **No authentication required** - the UI itself is public, but queries still require a valid API key. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGraphiQLApiResponse"/>&gt;</returns>
        Task<IGetGraphiQLApiResponse> GetGraphiQLAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// GraphiQL Interactive Explorer
        /// </summary>
        /// <remarks>
        /// Access the GraphiQL interactive query explorer.  GraphiQL provides: - Interactive query editor with syntax highlighting - Auto-complete for types and fields - Schema documentation browser - Query history  **No authentication required** - the UI itself is public, but queries still require a valid API key. 
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGraphiQLApiResponse"/>&gt;</returns>
        Task<IGetGraphiQLApiResponse> GetGraphiQLOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Graph Database Health Check
        /// </summary>
        /// <remarks>
        /// Check the health and connectivity of the graph database.  **No authentication required** - this is a public health endpoint.  Returns database status, connection info, and basic statistics. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetHealthApiResponse"/>&gt;</returns>
        Task<IGetHealthApiResponse> GetHealthAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Graph Database Health Check
        /// </summary>
        /// <remarks>
        /// Check the health and connectivity of the graph database.  **No authentication required** - this is a public health endpoint.  Returns database status, connection info, and basic statistics. 
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetHealthApiResponse"/>&gt;</returns>
        Task<IGetHealthApiResponse> GetHealthOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Graph Schema
        /// </summary>
        /// <remarks>
        /// Retrieve the graph database schema including available node labels, relationship types, and their properties.  Use this to discover what data is available for querying before writing Cypher or GraphQL queries.  **Response includes:** - Node labels (e.g., DomainName, A_ADDRESS, ASN) - Relationship types (e.g., hasIP, isListed, announces) - Properties available on each node and relationship type - Graph statistics (node and relationship counts) 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSchemaApiResponse"/>&gt;</returns>
        Task<IGetSchemaApiResponse> GetSchemaAsync(string authorization, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Graph Schema
        /// </summary>
        /// <remarks>
        /// Retrieve the graph database schema including available node labels, relationship types, and their properties.  Use this to discover what data is available for querying before writing Cypher or GraphQL queries.  **Response includes:** - Node labels (e.g., DomainName, A_ADDRESS, ASN) - Relationship types (e.g., hasIP, isListed, announces) - Properties available on each node and relationship type - Graph statistics (node and relationship counts) 
        /// </remarks>
        /// <param name="authorization"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSchemaApiResponse"/>&gt;</returns>
        Task<IGetSchemaApiResponse> GetSchemaOrDefaultAsync(string authorization, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IExecuteCypherQueryApiResponse"/>
    /// </summary>
    public interface IExecuteCypherQueryApiResponse : Whisper.Api.Sdk.Client.IApiResponse, IOk<Whisper.Api.Sdk.Model.CypherQueryResponse>, IBadRequest<Whisper.Api.Sdk.Model.ErrorResponse>, IUnauthorized<Whisper.Api.Sdk.Model.ErrorResponse>, IInternalServerError<Whisper.Api.Sdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IExecuteGraphQLApiResponse"/>
    /// </summary>
    public interface IExecuteGraphQLApiResponse : Whisper.Api.Sdk.Client.IApiResponse, IBadRequest<Whisper.Api.Sdk.Model.ErrorResponse>, IUnauthorized<Whisper.Api.Sdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetGraphiQLApiResponse"/>
    /// </summary>
    public interface IGetGraphiQLApiResponse : Whisper.Api.Sdk.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetHealthApiResponse"/>
    /// </summary>
    public interface IGetHealthApiResponse : Whisper.Api.Sdk.Client.IApiResponse, IOk<Object>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetSchemaApiResponse"/>
    /// </summary>
    public interface IGetSchemaApiResponse : Whisper.Api.Sdk.Client.IApiResponse, IOk<Whisper.Api.Sdk.Model.CypherSchemaResponse>, IUnauthorized<Whisper.Api.Sdk.Model.ErrorResponse>, IInternalServerError<Whisper.Api.Sdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class GraphDatabaseApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnExecuteCypherQuery;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorExecuteCypherQuery;

        internal void ExecuteOnExecuteCypherQuery(GraphDatabaseApi.ExecuteCypherQueryApiResponse apiResponse)
        {
            OnExecuteCypherQuery?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorExecuteCypherQuery(Exception exception)
        {
            OnErrorExecuteCypherQuery?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnExecuteGraphQL;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorExecuteGraphQL;

        internal void ExecuteOnExecuteGraphQL(GraphDatabaseApi.ExecuteGraphQLApiResponse apiResponse)
        {
            OnExecuteGraphQL?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorExecuteGraphQL(Exception exception)
        {
            OnErrorExecuteGraphQL?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetGraphiQL;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetGraphiQL;

        internal void ExecuteOnGetGraphiQL(GraphDatabaseApi.GetGraphiQLApiResponse apiResponse)
        {
            OnGetGraphiQL?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetGraphiQL(Exception exception)
        {
            OnErrorGetGraphiQL?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetHealth;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetHealth;

        internal void ExecuteOnGetHealth(GraphDatabaseApi.GetHealthApiResponse apiResponse)
        {
            OnGetHealth?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetHealth(Exception exception)
        {
            OnErrorGetHealth?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetSchema;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetSchema;

        internal void ExecuteOnGetSchema(GraphDatabaseApi.GetSchemaApiResponse apiResponse)
        {
            OnGetSchema?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSchema(Exception exception)
        {
            OnErrorGetSchema?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class GraphDatabaseApi : IGraphDatabaseApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<GraphDatabaseApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public GraphDatabaseApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="GraphDatabaseApi"/> class.
        /// </summary>
        /// <returns></returns>
        public GraphDatabaseApi(ILogger<GraphDatabaseApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, GraphDatabaseApiEvents graphDatabaseApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<GraphDatabaseApi>();
            HttpClient = httpClient;
            Events = graphDatabaseApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatExecuteCypherQuery(ref string authorization, CypherQueryRequest cypherQueryRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        /// <returns></returns>
        private void ValidateExecuteCypherQuery(string authorization, CypherQueryRequest cypherQueryRequest)
        {
            if (authorization == null)
                throw new ArgumentNullException(nameof(authorization));

            if (cypherQueryRequest == null)
                throw new ArgumentNullException(nameof(cypherQueryRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        private void AfterExecuteCypherQueryDefaultImplementation(IExecuteCypherQueryApiResponse apiResponseLocalVar, string authorization, CypherQueryRequest cypherQueryRequest)
        {
            bool suppressDefaultLog = false;
            AfterExecuteCypherQuery(ref suppressDefaultLog, apiResponseLocalVar, authorization, cypherQueryRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        partial void AfterExecuteCypherQuery(ref bool suppressDefaultLog, IExecuteCypherQueryApiResponse apiResponseLocalVar, string authorization, CypherQueryRequest cypherQueryRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        private void OnErrorExecuteCypherQueryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string authorization, CypherQueryRequest cypherQueryRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorExecuteCypherQuery(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, authorization, cypherQueryRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        partial void OnErrorExecuteCypherQuery(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string authorization, CypherQueryRequest cypherQueryRequest);

        /// <summary>
        /// Execute Cypher Query Execute a read-only Cypher query against the FalkorDB graph database.  **Security:** Only read operations (MATCH, RETURN) are allowed. Write operations are blocked.  **Example Queries:** &#x60;&#x60;&#x60;cypher // Find all IPs for a domain MATCH (d:DomainName {name: $domain})-[:hasIP]-&gt;(ip:A_ADDRESS) RETURN ip.name AS ip  // Find domains on blocklists MATCH (d:DomainName)-[:isListed]-&gt;(l:LIST) RETURN d.name, l.name LIMIT 10  // Get ASN and announced prefixes MATCH (asn:ASN {number: 15169})-[:announces]-&gt;(p:ANNOUNCED_PREFIX_4) RETURN p.name AS prefix &#x60;&#x60;&#x60;  **Performance Tips:** - Always use LIMIT to restrict result size - Use parameters for variable values - Filter early in the query with WHERE clauses 
        /// </summary>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExecuteCypherQueryApiResponse"/>&gt;</returns>
        public async Task<IExecuteCypherQueryApiResponse> ExecuteCypherQueryOrDefaultAsync(string authorization, CypherQueryRequest cypherQueryRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ExecuteCypherQueryAsync(authorization, cypherQueryRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Execute Cypher Query Execute a read-only Cypher query against the FalkorDB graph database.  **Security:** Only read operations (MATCH, RETURN) are allowed. Write operations are blocked.  **Example Queries:** &#x60;&#x60;&#x60;cypher // Find all IPs for a domain MATCH (d:DomainName {name: $domain})-[:hasIP]-&gt;(ip:A_ADDRESS) RETURN ip.name AS ip  // Find domains on blocklists MATCH (d:DomainName)-[:isListed]-&gt;(l:LIST) RETURN d.name, l.name LIMIT 10  // Get ASN and announced prefixes MATCH (asn:ASN {number: 15169})-[:announces]-&gt;(p:ANNOUNCED_PREFIX_4) RETURN p.name AS prefix &#x60;&#x60;&#x60;  **Performance Tips:** - Always use LIMIT to restrict result size - Use parameters for variable values - Filter early in the query with WHERE clauses 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization"></param>
        /// <param name="cypherQueryRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExecuteCypherQueryApiResponse"/>&gt;</returns>
        public async Task<IExecuteCypherQueryApiResponse> ExecuteCypherQueryAsync(string authorization, CypherQueryRequest cypherQueryRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateExecuteCypherQuery(authorization, cypherQueryRequest);

                FormatExecuteCypherQuery(ref authorization, cypherQueryRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/ops/graph/cypher"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/ops/graph/cypher");

                    httpRequestMessageLocalVar.Headers.Add("Authorization", ClientUtils.ParameterToString(authorization));

                    httpRequestMessageLocalVar.Content = (cypherQueryRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(cypherQueryRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ExecuteCypherQueryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ExecuteCypherQueryApiResponse>();
                        ExecuteCypherQueryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/ops/graph/cypher", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterExecuteCypherQueryDefaultImplementation(apiResponseLocalVar, authorization, cypherQueryRequest);

                        Events.ExecuteOnExecuteCypherQuery(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorExecuteCypherQueryDefaultImplementation(e, "/v1/ops/graph/cypher", uriBuilderLocalVar.Path, authorization, cypherQueryRequest);
                Events.ExecuteOnErrorExecuteCypherQuery(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ExecuteCypherQueryApiResponse"/>
        /// </summary>
        public partial class ExecuteCypherQueryApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IExecuteCypherQueryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ExecuteCypherQueryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ExecuteCypherQueryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ExecuteCypherQueryApiResponse(ILogger<ExecuteCypherQueryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ExecuteCypherQueryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ExecuteCypherQueryApiResponse(ILogger<ExecuteCypherQueryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.CypherQueryResponse Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.CypherQueryResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Whisper.Api.Sdk.Model.CypherQueryResponse result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatExecuteGraphQL(ref string authorization, GraphQLRequest graphQLRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        /// <returns></returns>
        private void ValidateExecuteGraphQL(string authorization, GraphQLRequest graphQLRequest)
        {
            if (authorization == null)
                throw new ArgumentNullException(nameof(authorization));

            if (graphQLRequest == null)
                throw new ArgumentNullException(nameof(graphQLRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        private void AfterExecuteGraphQLDefaultImplementation(IExecuteGraphQLApiResponse apiResponseLocalVar, string authorization, GraphQLRequest graphQLRequest)
        {
            bool suppressDefaultLog = false;
            AfterExecuteGraphQL(ref suppressDefaultLog, apiResponseLocalVar, authorization, graphQLRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        partial void AfterExecuteGraphQL(ref bool suppressDefaultLog, IExecuteGraphQLApiResponse apiResponseLocalVar, string authorization, GraphQLRequest graphQLRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        private void OnErrorExecuteGraphQLDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string authorization, GraphQLRequest graphQLRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorExecuteGraphQL(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, authorization, graphQLRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        partial void OnErrorExecuteGraphQL(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string authorization, GraphQLRequest graphQLRequest);

        /// <summary>
        /// Execute GraphQL Query Execute a GraphQL query against the graph database.  GraphQL provides a type-safe, structured alternative to Cypher for querying the graph data.  **Available Query Operations:** - &#x60;domain(name: String!)&#x60; - Look up domain information - &#x60;ipv4(address: String!)&#x60; - Look up IPv4 address information - &#x60;ipv6(address: String!)&#x60; - Look up IPv6 address information - &#x60;asn(number: Int!)&#x60; - Look up ASN information - &#x60;searchDomains(pattern: String!, limit: Int)&#x60; - Search domains by pattern - &#x60;domainsOnIP(address: String!)&#x60; - Find domains on an IP - &#x60;domainsOnASN(asnNumber: Int!, limit: Int)&#x60; - Find domains on an ASN - &#x60;checkIndicator(indicator: String!)&#x60; - Check if indicator is listed  **Example Query:** &#x60;&#x60;&#x60;graphql {   domain(name: \&quot;google.com\&quot;) {     name     ipAddresses {       address       country { code }     }     nameservers { name }     asns { number }   } } &#x60;&#x60;&#x60;  Use the &#x60;/v1/ops/graph/graphiql&#x60; endpoint for an interactive query explorer with schema documentation. 
        /// </summary>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExecuteGraphQLApiResponse"/>&gt;</returns>
        public async Task<IExecuteGraphQLApiResponse> ExecuteGraphQLOrDefaultAsync(string authorization, GraphQLRequest graphQLRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ExecuteGraphQLAsync(authorization, graphQLRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Execute GraphQL Query Execute a GraphQL query against the graph database.  GraphQL provides a type-safe, structured alternative to Cypher for querying the graph data.  **Available Query Operations:** - &#x60;domain(name: String!)&#x60; - Look up domain information - &#x60;ipv4(address: String!)&#x60; - Look up IPv4 address information - &#x60;ipv6(address: String!)&#x60; - Look up IPv6 address information - &#x60;asn(number: Int!)&#x60; - Look up ASN information - &#x60;searchDomains(pattern: String!, limit: Int)&#x60; - Search domains by pattern - &#x60;domainsOnIP(address: String!)&#x60; - Find domains on an IP - &#x60;domainsOnASN(asnNumber: Int!, limit: Int)&#x60; - Find domains on an ASN - &#x60;checkIndicator(indicator: String!)&#x60; - Check if indicator is listed  **Example Query:** &#x60;&#x60;&#x60;graphql {   domain(name: \&quot;google.com\&quot;) {     name     ipAddresses {       address       country { code }     }     nameservers { name }     asns { number }   } } &#x60;&#x60;&#x60;  Use the &#x60;/v1/ops/graph/graphiql&#x60; endpoint for an interactive query explorer with schema documentation. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization"></param>
        /// <param name="graphQLRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExecuteGraphQLApiResponse"/>&gt;</returns>
        public async Task<IExecuteGraphQLApiResponse> ExecuteGraphQLAsync(string authorization, GraphQLRequest graphQLRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateExecuteGraphQL(authorization, graphQLRequest);

                FormatExecuteGraphQL(ref authorization, graphQLRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/ops/graph/graphql"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/ops/graph/graphql");

                    httpRequestMessageLocalVar.Headers.Add("Authorization", ClientUtils.ParameterToString(authorization));

                    httpRequestMessageLocalVar.Content = (graphQLRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(graphQLRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ExecuteGraphQLApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ExecuteGraphQLApiResponse>();
                        ExecuteGraphQLApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/ops/graph/graphql", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterExecuteGraphQLDefaultImplementation(apiResponseLocalVar, authorization, graphQLRequest);

                        Events.ExecuteOnExecuteGraphQL(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorExecuteGraphQLDefaultImplementation(e, "/v1/ops/graph/graphql", uriBuilderLocalVar.Path, authorization, graphQLRequest);
                Events.ExecuteOnErrorExecuteGraphQL(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ExecuteGraphQLApiResponse"/>
        /// </summary>
        public partial class ExecuteGraphQLApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IExecuteGraphQLApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ExecuteGraphQLApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ExecuteGraphQLApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ExecuteGraphQLApiResponse(ILogger<ExecuteGraphQLApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ExecuteGraphQLApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ExecuteGraphQLApiResponse(ILogger<ExecuteGraphQLApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetGraphiQLDefaultImplementation(IGetGraphiQLApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetGraphiQL(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetGraphiQL(ref bool suppressDefaultLog, IGetGraphiQLApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetGraphiQLDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetGraphiQL(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetGraphiQL(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// GraphiQL Interactive Explorer Access the GraphiQL interactive query explorer.  GraphiQL provides: - Interactive query editor with syntax highlighting - Auto-complete for types and fields - Schema documentation browser - Query history  **No authentication required** - the UI itself is public, but queries still require a valid API key. 
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGraphiQLApiResponse"/>&gt;</returns>
        public async Task<IGetGraphiQLApiResponse> GetGraphiQLOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetGraphiQLAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// GraphiQL Interactive Explorer Access the GraphiQL interactive query explorer.  GraphiQL provides: - Interactive query editor with syntax highlighting - Auto-complete for types and fields - Schema documentation browser - Query history  **No authentication required** - the UI itself is public, but queries still require a valid API key. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetGraphiQLApiResponse"/>&gt;</returns>
        public async Task<IGetGraphiQLApiResponse> GetGraphiQLAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/ops/graph/graphiql"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/ops/graph/graphiql");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "text/html"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetGraphiQLApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetGraphiQLApiResponse>();
                        GetGraphiQLApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/ops/graph/graphiql", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetGraphiQLDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetGraphiQL(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetGraphiQLDefaultImplementation(e, "/v1/ops/graph/graphiql", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetGraphiQL(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetGraphiQLApiResponse"/>
        /// </summary>
        public partial class GetGraphiQLApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IGetGraphiQLApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetGraphiQLApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetGraphiQLApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetGraphiQLApiResponse(ILogger<GetGraphiQLApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetGraphiQLApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetGraphiQLApiResponse(ILogger<GetGraphiQLApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetHealthDefaultImplementation(IGetHealthApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetHealth(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetHealth(ref bool suppressDefaultLog, IGetHealthApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetHealthDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetHealth(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetHealth(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Graph Database Health Check Check the health and connectivity of the graph database.  **No authentication required** - this is a public health endpoint.  Returns database status, connection info, and basic statistics. 
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetHealthApiResponse"/>&gt;</returns>
        public async Task<IGetHealthApiResponse> GetHealthOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetHealthAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Graph Database Health Check Check the health and connectivity of the graph database.  **No authentication required** - this is a public health endpoint.  Returns database status, connection info, and basic statistics. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetHealthApiResponse"/>&gt;</returns>
        public async Task<IGetHealthApiResponse> GetHealthAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/ops/graph/health"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/ops/graph/health");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetHealthApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetHealthApiResponse>();
                        GetHealthApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/ops/graph/health", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetHealthDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetHealth(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetHealthDefaultImplementation(e, "/v1/ops/graph/health", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetHealth(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetHealthApiResponse"/>
        /// </summary>
        public partial class GetHealthApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IGetHealthApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetHealthApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetHealthApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetHealthApiResponse(ILogger<GetHealthApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetHealthApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetHealthApiResponse(ILogger<GetHealthApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Object Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Object>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Object result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSchema(ref string authorization);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="authorization"></param>
        /// <returns></returns>
        private void ValidateGetSchema(string authorization)
        {
            if (authorization == null)
                throw new ArgumentNullException(nameof(authorization));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="authorization"></param>
        private void AfterGetSchemaDefaultImplementation(IGetSchemaApiResponse apiResponseLocalVar, string authorization)
        {
            bool suppressDefaultLog = false;
            AfterGetSchema(ref suppressDefaultLog, apiResponseLocalVar, authorization);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="authorization"></param>
        partial void AfterGetSchema(ref bool suppressDefaultLog, IGetSchemaApiResponse apiResponseLocalVar, string authorization);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="authorization"></param>
        private void OnErrorGetSchemaDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string authorization)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSchema(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, authorization);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="authorization"></param>
        partial void OnErrorGetSchema(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string authorization);

        /// <summary>
        /// Get Graph Schema Retrieve the graph database schema including available node labels, relationship types, and their properties.  Use this to discover what data is available for querying before writing Cypher or GraphQL queries.  **Response includes:** - Node labels (e.g., DomainName, A_ADDRESS, ASN) - Relationship types (e.g., hasIP, isListed, announces) - Properties available on each node and relationship type - Graph statistics (node and relationship counts) 
        /// </summary>
        /// <param name="authorization"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSchemaApiResponse"/>&gt;</returns>
        public async Task<IGetSchemaApiResponse> GetSchemaOrDefaultAsync(string authorization, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSchemaAsync(authorization, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Graph Schema Retrieve the graph database schema including available node labels, relationship types, and their properties.  Use this to discover what data is available for querying before writing Cypher or GraphQL queries.  **Response includes:** - Node labels (e.g., DomainName, A_ADDRESS, ASN) - Relationship types (e.g., hasIP, isListed, announces) - Properties available on each node and relationship type - Graph statistics (node and relationship counts) 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="authorization"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSchemaApiResponse"/>&gt;</returns>
        public async Task<IGetSchemaApiResponse> GetSchemaAsync(string authorization, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSchema(authorization);

                FormatGetSchema(ref authorization);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/ops/graph/schema"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/ops/graph/schema");

                    httpRequestMessageLocalVar.Headers.Add("Authorization", ClientUtils.ParameterToString(authorization));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetSchemaApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSchemaApiResponse>();
                        GetSchemaApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/ops/graph/schema", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetSchemaDefaultImplementation(apiResponseLocalVar, authorization);

                        Events.ExecuteOnGetSchema(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSchemaDefaultImplementation(e, "/v1/ops/graph/schema", uriBuilderLocalVar.Path, authorization);
                Events.ExecuteOnErrorGetSchema(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSchemaApiResponse"/>
        /// </summary>
        public partial class GetSchemaApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IGetSchemaApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSchemaApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSchemaApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSchemaApiResponse(ILogger<GetSchemaApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetSchemaApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSchemaApiResponse(ILogger<GetSchemaApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.CypherSchemaResponse Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.CypherSchemaResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Whisper.Api.Sdk.Model.CypherSchemaResponse result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
