// <auto-generated>
/*
 * Whisper API v1
 *
 * <h2>The Foundational Intelligence Layer for the Internet</h2> <p>The Whisper API provides comprehensive, real-time intelligence on any internet asset. By connecting billions of data points across live internet routing, historical registration records, and deep resolution data, our API moves beyond simple enrichment to deliver predictive, context-rich insights.</p> <p>This document is the single source of truth for our v1 API. It is designed for security experts, developers, and automated systems to understand and leverage the full power of our platform.</p>  <h3>üöÄ Quick Start</h3> <p><b>1. Get your API key:</b> <a href=\"https://dash.whisper.security\">Sign up at dash.whisper.security</a></p> <p><b>2. Make your first request:</b></p> <pre><code>curl -H \"Authorization: Bearer YOUR_API_KEY\" https://api.whisper.security/v1/indicators/ip/8.8.8.8</code></pre> <p><b>3. Explore the API:</b> Use the \"Try it out\" button in each endpoint below to test interactively.</p>  <h3>üéØ Key Features</h3> <ul>     <li><b>Unified & Simple:</b> Small set of powerful, resource-oriented endpoints</li>     <li><b>Performant by Design:</b> Asynchronous-first with strategic caching (&lt;500ms typical response)</li>     <li><b>Workflow-Oriented:</b> Built for real-world security operations, not just data dumps</li>     <li><b>Comprehensive:</b> IP, Domain, DNS, WHOIS, Routing, Geolocation, Screenshots, Monitoring</li> </ul>  <h3>‚ö° Performance Targets</h3> <table>     <tr><th>Endpoint Type</th><th>Response Time</th><th>Use Case</th></tr>     <tr><td>Geolocation</td><td>&lt;150ms</td><td>Real-time fraud detection</td></tr>     <tr><td>Single Indicator</td><td>&lt;500ms</td><td>Incident response enrichment</td></tr>     <tr><td>With Routing Data</td><td>&lt;2s (cached: 200ms)</td><td>Deep network analysis</td></tr>     <tr><td>Bulk Operations</td><td>5-30s</td><td>Batch log enrichment</td></tr>     <tr><td>Search/Discovery</td><td>10-60s</td><td>Threat hunting</td></tr> </table>  <h3>üîê Authentication</h3> <p>All endpoints require Bearer token authentication. Click the <b>\"Authorize\"</b> button above and enter your API key.</p> <pre><code>Authorization: Bearer wsk_live_1234567890abcdef</code></pre>  <h3>üìä Rate Limits</h3> <table>     <tr><th>Category</th><th>Limit</th></tr>     <tr><td>Standard Enrichment</td><td>100 req/min</td></tr>     <tr><td>Bulk Operations</td><td>10 req/min</td></tr>     <tr><td>Search/Discovery</td><td>5 req/min</td></tr>     <tr><td>Screenshots</td><td>10 req/min</td></tr> </table> <p><i>Rate limits return HTTP 429. Retry after the time specified in the <code>Retry-After</code> header.</i></p>  <h3>üìö Resources</h3> <ul>     <li><a href=\"https://docs.whisper.security\">Full Documentation</a></li>     <li><a href=\"https://docs.whisper.security/quickstart\">Quick Start Guide</a></li>     <li><a href=\"https://docs.whisper.security/examples\">Code Examples</a></li>     <li><a href=\"https://whisper.security/support\">API Support</a></li> </ul> 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api-support@whisper.security
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Whisper.Api.Sdk.Client;
using Whisper.Api.Sdk.Model;
using System.Diagnostics.CodeAnalysis;

namespace Whisper.Api.Sdk.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ILocationApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        LocationApiEvents Events { get; }

        /// <summary>
        /// Bulk IP Geolocation Lookup
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Retrieve geolocation data for up to 1000 IP addresses in a single request. Optimized for batch processing with parallel lookups.&lt;/p&gt; &lt;h4&gt;Request Format:&lt;/h4&gt; &lt;p&gt;Send a JSON array of IP addresses (IPv4 or IPv6):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;[\&quot;8.8.8.8\&quot;, \&quot;1.1.1.1\&quot;, \&quot;208.67.222.222\&quot;]&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; 500-2000ms for typical batches (10-100 IPs)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Processing:&lt;/b&gt; Parallel lookups with automatic batching&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Limit:&lt;/b&gt; Maximum 1000 IPs per request&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Rate Limit:&lt;/b&gt; 10 requests per minute&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Response Format:&lt;/h4&gt; &lt;p&gt;Returns an array of geolocation objects matching the order of input IPs. Failed lookups are indicated with error objects.&lt;/p&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Batch enrichment of access logs&lt;/li&gt;     &lt;li&gt;Bulk fraud scoring&lt;/li&gt;     &lt;li&gt;Geographic distribution analysis&lt;/li&gt;     &lt;li&gt;Network infrastructure mapping&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">JSON array of IP addresses to lookup. Maximum 1000 IPs per request.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBulkIpLocationApiResponse"/>&gt;</returns>
        Task<IGetBulkIpLocationApiResponse> GetBulkIpLocationAsync(List<string> requestBody, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Bulk IP Geolocation Lookup
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Retrieve geolocation data for up to 1000 IP addresses in a single request. Optimized for batch processing with parallel lookups.&lt;/p&gt; &lt;h4&gt;Request Format:&lt;/h4&gt; &lt;p&gt;Send a JSON array of IP addresses (IPv4 or IPv6):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;[\&quot;8.8.8.8\&quot;, \&quot;1.1.1.1\&quot;, \&quot;208.67.222.222\&quot;]&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; 500-2000ms for typical batches (10-100 IPs)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Processing:&lt;/b&gt; Parallel lookups with automatic batching&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Limit:&lt;/b&gt; Maximum 1000 IPs per request&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Rate Limit:&lt;/b&gt; 10 requests per minute&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Response Format:&lt;/h4&gt; &lt;p&gt;Returns an array of geolocation objects matching the order of input IPs. Failed lookups are indicated with error objects.&lt;/p&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Batch enrichment of access logs&lt;/li&gt;     &lt;li&gt;Bulk fraud scoring&lt;/li&gt;     &lt;li&gt;Geographic distribution analysis&lt;/li&gt;     &lt;li&gt;Network infrastructure mapping&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <param name="requestBody">JSON array of IP addresses to lookup. Maximum 1000 IPs per request.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBulkIpLocationApiResponse"/>&gt;</returns>
        Task<IGetBulkIpLocationApiResponse> GetBulkIpLocationOrDefaultAsync(List<string> requestBody, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get IP Geolocation and ASN Data
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Returns comprehensive geolocation and network information for any IPv4 or IPv6 address. This is one of the fastest endpoints in the API, optimized for real-time fraud detection and access control.&lt;/p&gt; &lt;h4&gt;Data Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Country, city, region, postal code, coordinates, timezone&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; ASN, ISP/organization name, network range&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Classification:&lt;/b&gt; Connection type (residential, datacenter, VPN, proxy, hosting)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Reputation:&lt;/b&gt; Risk indicators and abuse scores&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; Typically &amp;lt;150ms&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Cache:&lt;/b&gt; Results cached for 6 hours by default&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Real-time fraud detection in payment flows&lt;/li&gt;     &lt;li&gt;Geographic access control and compliance&lt;/li&gt;     &lt;li&gt;Bot and VPN detection&lt;/li&gt;     &lt;li&gt;Threat intelligence enrichment&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ip">The IPv4 or IPv6 address to lookup.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIpLocationApiResponse"/>&gt;</returns>
        Task<IGetIpLocationApiResponse> GetIpLocationAsync(string ip, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get IP Geolocation and ASN Data
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Returns comprehensive geolocation and network information for any IPv4 or IPv6 address. This is one of the fastest endpoints in the API, optimized for real-time fraud detection and access control.&lt;/p&gt; &lt;h4&gt;Data Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Country, city, region, postal code, coordinates, timezone&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; ASN, ISP/organization name, network range&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Classification:&lt;/b&gt; Connection type (residential, datacenter, VPN, proxy, hosting)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Reputation:&lt;/b&gt; Risk indicators and abuse scores&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; Typically &amp;lt;150ms&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Cache:&lt;/b&gt; Results cached for 6 hours by default&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Real-time fraud detection in payment flows&lt;/li&gt;     &lt;li&gt;Geographic access control and compliance&lt;/li&gt;     &lt;li&gt;Bot and VPN detection&lt;/li&gt;     &lt;li&gt;Threat intelligence enrichment&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <param name="ip">The IPv4 or IPv6 address to lookup.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIpLocationApiResponse"/>&gt;</returns>
        Task<IGetIpLocationApiResponse> GetIpLocationOrDefaultAsync(string ip, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Geolocation Database Statistics
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Returns metadata and statistics about the geolocation database, including coverage, update frequency, and data quality metrics.&lt;/p&gt; &lt;h4&gt;Statistics Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Coverage:&lt;/b&gt; Total IP addresses, networks, and ASNs covered&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Number of countries, cities, and regions&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Freshness:&lt;/b&gt; Last update timestamp and update frequency&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Data Sources:&lt;/b&gt; Providers and data collection methods&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Accuracy:&lt;/b&gt; Quality metrics and confidence scores&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Verifying database coverage for your use case&lt;/li&gt;     &lt;li&gt;Monitoring data freshness&lt;/li&gt;     &lt;li&gt;Understanding data quality and accuracy&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationStatsApiResponse"/>&gt;</returns>
        Task<IGetLocationStatsApiResponse> GetLocationStatsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Geolocation Database Statistics
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Returns metadata and statistics about the geolocation database, including coverage, update frequency, and data quality metrics.&lt;/p&gt; &lt;h4&gt;Statistics Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Coverage:&lt;/b&gt; Total IP addresses, networks, and ASNs covered&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Number of countries, cities, and regions&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Freshness:&lt;/b&gt; Last update timestamp and update frequency&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Data Sources:&lt;/b&gt; Providers and data collection methods&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Accuracy:&lt;/b&gt; Quality metrics and confidence scores&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Verifying database coverage for your use case&lt;/li&gt;     &lt;li&gt;Monitoring data freshness&lt;/li&gt;     &lt;li&gt;Understanding data quality and accuracy&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationStatsApiResponse"/>&gt;</returns>
        Task<IGetLocationStatsApiResponse> GetLocationStatsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Network/CIDR Geolocation Data
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Returns geolocation and network information for an entire network range specified in CIDR notation. Useful for analyzing network blocks, ranges, and subnets.&lt;/p&gt; &lt;h4&gt;Supported Formats:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;IPv4 CIDR:&lt;/b&gt; 192.168.1.0/24&lt;/li&gt;     &lt;li&gt;&lt;b&gt;IPv6 CIDR:&lt;/b&gt; 2001:db8::/32&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Data Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Network Details:&lt;/b&gt; CIDR range, first/last IP, total addresses&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Country, city, region for the network block&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; ASN, organization, ISP information&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Classification:&lt;/b&gt; Network type and usage category&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Analyzing suspicious network ranges&lt;/li&gt;     &lt;li&gt;Bulk geolocation for network blocks&lt;/li&gt;     &lt;li&gt;Infrastructure mapping and reconnaissance&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="network">The network range in CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32).</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkLocationApiResponse"/>&gt;</returns>
        Task<IGetNetworkLocationApiResponse> GetNetworkLocationAsync(string network, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Network/CIDR Geolocation Data
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Returns geolocation and network information for an entire network range specified in CIDR notation. Useful for analyzing network blocks, ranges, and subnets.&lt;/p&gt; &lt;h4&gt;Supported Formats:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;IPv4 CIDR:&lt;/b&gt; 192.168.1.0/24&lt;/li&gt;     &lt;li&gt;&lt;b&gt;IPv6 CIDR:&lt;/b&gt; 2001:db8::/32&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Data Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Network Details:&lt;/b&gt; CIDR range, first/last IP, total addresses&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Country, city, region for the network block&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; ASN, organization, ISP information&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Classification:&lt;/b&gt; Network type and usage category&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Analyzing suspicious network ranges&lt;/li&gt;     &lt;li&gt;Bulk geolocation for network blocks&lt;/li&gt;     &lt;li&gt;Infrastructure mapping and reconnaissance&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <param name="network">The network range in CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32).</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkLocationApiResponse"/>&gt;</returns>
        Task<IGetNetworkLocationApiResponse> GetNetworkLocationOrDefaultAsync(string network, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Geolocation Database by Field
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Search the geolocation database by specific fields to find all IP addresses matching your criteria. Powerful for threat hunting, infrastructure discovery, and pattern analysis.&lt;/p&gt; &lt;h4&gt;Searchable Fields:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; city, country, country_code, region, postal_code, continent, continent_code&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; asn, as_number, organization, isp, isp_name&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Coordinates:&lt;/b&gt; latitude, longitude&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Query Examples:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Find all IPs in a city:&lt;/b&gt; field&#x3D;city&amp;value&#x3D;London&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs for an ASN:&lt;/b&gt; field&#x3D;asn&amp;value&#x3D;15169&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs for an ISP:&lt;/b&gt; field&#x3D;isp_name&amp;value&#x3D;Google&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs in country:&lt;/b&gt; field&#x3D;country_code&amp;value&#x3D;US&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; 200-500ms depending on result size&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Rate Limit:&lt;/b&gt; 5 searches per minute&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Infrastructure mapping for threat actors&lt;/li&gt;     &lt;li&gt;Finding all IPs in a specific region for compliance&lt;/li&gt;     &lt;li&gt;Discovering VPN/proxy exit nodes&lt;/li&gt;     &lt;li&gt;Threat hunting by ISP or ASN&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="field">The field to search. Valid fields: city, country, country_code, isp_name, isp, asn, as_number, organization, continent, continent_code, region, postal_code, latitude, longitude</param>
        /// <param name="value">The value to search for in the specified field.</param>
        /// <param name="limit">Maximum number of results to return. (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchLocationApiResponse"/>&gt;</returns>
        Task<ISearchLocationApiResponse> SearchLocationAsync(string field, string value, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search Geolocation Database by Field
        /// </summary>
        /// <remarks>
        /// &lt;p&gt;Search the geolocation database by specific fields to find all IP addresses matching your criteria. Powerful for threat hunting, infrastructure discovery, and pattern analysis.&lt;/p&gt; &lt;h4&gt;Searchable Fields:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; city, country, country_code, region, postal_code, continent, continent_code&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; asn, as_number, organization, isp, isp_name&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Coordinates:&lt;/b&gt; latitude, longitude&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Query Examples:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Find all IPs in a city:&lt;/b&gt; field&#x3D;city&amp;value&#x3D;London&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs for an ASN:&lt;/b&gt; field&#x3D;asn&amp;value&#x3D;15169&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs for an ISP:&lt;/b&gt; field&#x3D;isp_name&amp;value&#x3D;Google&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs in country:&lt;/b&gt; field&#x3D;country_code&amp;value&#x3D;US&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; 200-500ms depending on result size&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Rate Limit:&lt;/b&gt; 5 searches per minute&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Infrastructure mapping for threat actors&lt;/li&gt;     &lt;li&gt;Finding all IPs in a specific region for compliance&lt;/li&gt;     &lt;li&gt;Discovering VPN/proxy exit nodes&lt;/li&gt;     &lt;li&gt;Threat hunting by ISP or ASN&lt;/li&gt; &lt;/ul&gt; 
        /// </remarks>
        /// <param name="field">The field to search. Valid fields: city, country, country_code, isp_name, isp, asn, as_number, organization, continent, continent_code, region, postal_code, latitude, longitude</param>
        /// <param name="value">The value to search for in the specified field.</param>
        /// <param name="limit">Maximum number of results to return. (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchLocationApiResponse"/>&gt;</returns>
        Task<ISearchLocationApiResponse> SearchLocationOrDefaultAsync(string field, string value, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetBulkIpLocationApiResponse"/>
    /// </summary>
    public interface IGetBulkIpLocationApiResponse : Whisper.Api.Sdk.Client.IApiResponse, ITooManyRequests<Whisper.Api.Sdk.Model.ErrorResponse>, IUnauthorized<Whisper.Api.Sdk.Model.ErrorResponse>, IBadRequest<Whisper.Api.Sdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IGetIpLocationApiResponse"/>
    /// </summary>
    public interface IGetIpLocationApiResponse : Whisper.Api.Sdk.Client.IApiResponse, INotFound<Whisper.Api.Sdk.Model.ErrorResponse>, ITooManyRequests<Whisper.Api.Sdk.Model.ErrorResponse>, IBadRequest<Whisper.Api.Sdk.Model.ErrorResponse>, IUnauthorized<Whisper.Api.Sdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetLocationStatsApiResponse"/>
    /// </summary>
    public interface IGetLocationStatsApiResponse : Whisper.Api.Sdk.Client.IApiResponse, IUnauthorized<Whisper.Api.Sdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="IGetNetworkLocationApiResponse"/>
    /// </summary>
    public interface IGetNetworkLocationApiResponse : Whisper.Api.Sdk.Client.IApiResponse, IBadRequest<Whisper.Api.Sdk.Model.ErrorResponse>, INotFound<Whisper.Api.Sdk.Model.ErrorResponse>, IUnauthorized<Whisper.Api.Sdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// The <see cref="ISearchLocationApiResponse"/>
    /// </summary>
    public interface ISearchLocationApiResponse : Whisper.Api.Sdk.Client.IApiResponse, IBadRequest<Whisper.Api.Sdk.Model.ErrorResponse>, ITooManyRequests<Whisper.Api.Sdk.Model.ErrorResponse>, IUnauthorized<Whisper.Api.Sdk.Model.ErrorResponse>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class LocationApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetBulkIpLocation;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetBulkIpLocation;

        internal void ExecuteOnGetBulkIpLocation(LocationApi.GetBulkIpLocationApiResponse apiResponse)
        {
            OnGetBulkIpLocation?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetBulkIpLocation(Exception exception)
        {
            OnErrorGetBulkIpLocation?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetIpLocation;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetIpLocation;

        internal void ExecuteOnGetIpLocation(LocationApi.GetIpLocationApiResponse apiResponse)
        {
            OnGetIpLocation?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetIpLocation(Exception exception)
        {
            OnErrorGetIpLocation?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetLocationStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetLocationStats;

        internal void ExecuteOnGetLocationStats(LocationApi.GetLocationStatsApiResponse apiResponse)
        {
            OnGetLocationStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLocationStats(Exception exception)
        {
            OnErrorGetLocationStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnGetNetworkLocation;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorGetNetworkLocation;

        internal void ExecuteOnGetNetworkLocation(LocationApi.GetNetworkLocationApiResponse apiResponse)
        {
            OnGetNetworkLocation?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetNetworkLocation(Exception exception)
        {
            OnErrorGetNetworkLocation?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs> OnSearchLocation;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs> OnErrorSearchLocation;

        internal void ExecuteOnSearchLocation(LocationApi.SearchLocationApiResponse apiResponse)
        {
            OnSearchLocation?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSearchLocation(Exception exception)
        {
            OnErrorSearchLocation?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class LocationApi : ILocationApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<LocationApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public LocationApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="LocationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public LocationApi(ILogger<LocationApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, LocationApiEvents locationApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<LocationApi>();
            HttpClient = httpClient;
            Events = locationApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatGetBulkIpLocation(List<string> requestBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="requestBody"></param>
        /// <returns></returns>
        private void ValidateGetBulkIpLocation(List<string> requestBody)
        {
            if (requestBody == null)
                throw new ArgumentNullException(nameof(requestBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="requestBody"></param>
        private void AfterGetBulkIpLocationDefaultImplementation(IGetBulkIpLocationApiResponse apiResponseLocalVar, List<string> requestBody)
        {
            bool suppressDefaultLog = false;
            AfterGetBulkIpLocation(ref suppressDefaultLog, apiResponseLocalVar, requestBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="requestBody"></param>
        partial void AfterGetBulkIpLocation(ref bool suppressDefaultLog, IGetBulkIpLocationApiResponse apiResponseLocalVar, List<string> requestBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="requestBody"></param>
        private void OnErrorGetBulkIpLocationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> requestBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetBulkIpLocation(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, requestBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="requestBody"></param>
        partial void OnErrorGetBulkIpLocation(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> requestBody);

        /// <summary>
        /// Bulk IP Geolocation Lookup &lt;p&gt;Retrieve geolocation data for up to 1000 IP addresses in a single request. Optimized for batch processing with parallel lookups.&lt;/p&gt; &lt;h4&gt;Request Format:&lt;/h4&gt; &lt;p&gt;Send a JSON array of IP addresses (IPv4 or IPv6):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;[\&quot;8.8.8.8\&quot;, \&quot;1.1.1.1\&quot;, \&quot;208.67.222.222\&quot;]&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; 500-2000ms for typical batches (10-100 IPs)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Processing:&lt;/b&gt; Parallel lookups with automatic batching&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Limit:&lt;/b&gt; Maximum 1000 IPs per request&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Rate Limit:&lt;/b&gt; 10 requests per minute&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Response Format:&lt;/h4&gt; &lt;p&gt;Returns an array of geolocation objects matching the order of input IPs. Failed lookups are indicated with error objects.&lt;/p&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Batch enrichment of access logs&lt;/li&gt;     &lt;li&gt;Bulk fraud scoring&lt;/li&gt;     &lt;li&gt;Geographic distribution analysis&lt;/li&gt;     &lt;li&gt;Network infrastructure mapping&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <param name="requestBody">JSON array of IP addresses to lookup. Maximum 1000 IPs per request.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBulkIpLocationApiResponse"/>&gt;</returns>
        public async Task<IGetBulkIpLocationApiResponse> GetBulkIpLocationOrDefaultAsync(List<string> requestBody, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetBulkIpLocationAsync(requestBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Bulk IP Geolocation Lookup &lt;p&gt;Retrieve geolocation data for up to 1000 IP addresses in a single request. Optimized for batch processing with parallel lookups.&lt;/p&gt; &lt;h4&gt;Request Format:&lt;/h4&gt; &lt;p&gt;Send a JSON array of IP addresses (IPv4 or IPv6):&lt;/p&gt; &lt;pre&gt;&lt;code&gt;[\&quot;8.8.8.8\&quot;, \&quot;1.1.1.1\&quot;, \&quot;208.67.222.222\&quot;]&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; 500-2000ms for typical batches (10-100 IPs)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Processing:&lt;/b&gt; Parallel lookups with automatic batching&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Limit:&lt;/b&gt; Maximum 1000 IPs per request&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Rate Limit:&lt;/b&gt; 10 requests per minute&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Response Format:&lt;/h4&gt; &lt;p&gt;Returns an array of geolocation objects matching the order of input IPs. Failed lookups are indicated with error objects.&lt;/p&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Batch enrichment of access logs&lt;/li&gt;     &lt;li&gt;Bulk fraud scoring&lt;/li&gt;     &lt;li&gt;Geographic distribution analysis&lt;/li&gt;     &lt;li&gt;Network infrastructure mapping&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestBody">JSON array of IP addresses to lookup. Maximum 1000 IPs per request.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBulkIpLocationApiResponse"/>&gt;</returns>
        public async Task<IGetBulkIpLocationApiResponse> GetBulkIpLocationAsync(List<string> requestBody, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetBulkIpLocation(requestBody);

                FormatGetBulkIpLocation(requestBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/location/ips/bulk"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/location/ips/bulk");

                    httpRequestMessageLocalVar.Content = (requestBody as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(requestBody, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetBulkIpLocationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetBulkIpLocationApiResponse>();
                        GetBulkIpLocationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/location/ips/bulk", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetBulkIpLocationDefaultImplementation(apiResponseLocalVar, requestBody);

                        Events.ExecuteOnGetBulkIpLocation(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetBulkIpLocationDefaultImplementation(e, "/v1/location/ips/bulk", uriBuilderLocalVar.Path, requestBody);
                Events.ExecuteOnErrorGetBulkIpLocation(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetBulkIpLocationApiResponse"/>
        /// </summary>
        public partial class GetBulkIpLocationApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IGetBulkIpLocationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetBulkIpLocationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetBulkIpLocationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBulkIpLocationApiResponse(ILogger<GetBulkIpLocationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetBulkIpLocationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBulkIpLocationApiResponse(ILogger<GetBulkIpLocationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetIpLocation(ref string ip);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="ip"></param>
        /// <returns></returns>
        private void ValidateGetIpLocation(string ip)
        {
            if (ip == null)
                throw new ArgumentNullException(nameof(ip));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ip"></param>
        private void AfterGetIpLocationDefaultImplementation(IGetIpLocationApiResponse apiResponseLocalVar, string ip)
        {
            bool suppressDefaultLog = false;
            AfterGetIpLocation(ref suppressDefaultLog, apiResponseLocalVar, ip);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ip"></param>
        partial void AfterGetIpLocation(ref bool suppressDefaultLog, IGetIpLocationApiResponse apiResponseLocalVar, string ip);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ip"></param>
        private void OnErrorGetIpLocationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string ip)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetIpLocation(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, ip);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ip"></param>
        partial void OnErrorGetIpLocation(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string ip);

        /// <summary>
        /// Get IP Geolocation and ASN Data &lt;p&gt;Returns comprehensive geolocation and network information for any IPv4 or IPv6 address. This is one of the fastest endpoints in the API, optimized for real-time fraud detection and access control.&lt;/p&gt; &lt;h4&gt;Data Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Country, city, region, postal code, coordinates, timezone&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; ASN, ISP/organization name, network range&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Classification:&lt;/b&gt; Connection type (residential, datacenter, VPN, proxy, hosting)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Reputation:&lt;/b&gt; Risk indicators and abuse scores&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; Typically &amp;lt;150ms&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Cache:&lt;/b&gt; Results cached for 6 hours by default&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Real-time fraud detection in payment flows&lt;/li&gt;     &lt;li&gt;Geographic access control and compliance&lt;/li&gt;     &lt;li&gt;Bot and VPN detection&lt;/li&gt;     &lt;li&gt;Threat intelligence enrichment&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <param name="ip">The IPv4 or IPv6 address to lookup.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIpLocationApiResponse"/>&gt;</returns>
        public async Task<IGetIpLocationApiResponse> GetIpLocationOrDefaultAsync(string ip, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetIpLocationAsync(ip, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get IP Geolocation and ASN Data &lt;p&gt;Returns comprehensive geolocation and network information for any IPv4 or IPv6 address. This is one of the fastest endpoints in the API, optimized for real-time fraud detection and access control.&lt;/p&gt; &lt;h4&gt;Data Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Country, city, region, postal code, coordinates, timezone&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; ASN, ISP/organization name, network range&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Classification:&lt;/b&gt; Connection type (residential, datacenter, VPN, proxy, hosting)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Reputation:&lt;/b&gt; Risk indicators and abuse scores&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; Typically &amp;lt;150ms&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Cache:&lt;/b&gt; Results cached for 6 hours by default&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Real-time fraud detection in payment flows&lt;/li&gt;     &lt;li&gt;Geographic access control and compliance&lt;/li&gt;     &lt;li&gt;Bot and VPN detection&lt;/li&gt;     &lt;li&gt;Threat intelligence enrichment&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ip">The IPv4 or IPv6 address to lookup.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIpLocationApiResponse"/>&gt;</returns>
        public async Task<IGetIpLocationApiResponse> GetIpLocationAsync(string ip, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetIpLocation(ip);

                FormatGetIpLocation(ref ip);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/location/ip/{ip}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/location/ip/{ip}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bip%7D", Uri.EscapeDataString(ip.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetIpLocationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetIpLocationApiResponse>();
                        GetIpLocationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/location/ip/{ip}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetIpLocationDefaultImplementation(apiResponseLocalVar, ip);

                        Events.ExecuteOnGetIpLocation(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetIpLocationDefaultImplementation(e, "/v1/location/ip/{ip}", uriBuilderLocalVar.Path, ip);
                Events.ExecuteOnErrorGetIpLocation(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetIpLocationApiResponse"/>
        /// </summary>
        public partial class GetIpLocationApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IGetIpLocationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetIpLocationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetIpLocationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIpLocationApiResponse(ILogger<GetIpLocationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetIpLocationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIpLocationApiResponse(ILogger<GetIpLocationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetLocationStatsDefaultImplementation(IGetLocationStatsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetLocationStats(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetLocationStats(ref bool suppressDefaultLog, IGetLocationStatsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetLocationStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLocationStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetLocationStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get Geolocation Database Statistics &lt;p&gt;Returns metadata and statistics about the geolocation database, including coverage, update frequency, and data quality metrics.&lt;/p&gt; &lt;h4&gt;Statistics Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Coverage:&lt;/b&gt; Total IP addresses, networks, and ASNs covered&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Number of countries, cities, and regions&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Freshness:&lt;/b&gt; Last update timestamp and update frequency&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Data Sources:&lt;/b&gt; Providers and data collection methods&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Accuracy:&lt;/b&gt; Quality metrics and confidence scores&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Verifying database coverage for your use case&lt;/li&gt;     &lt;li&gt;Monitoring data freshness&lt;/li&gt;     &lt;li&gt;Understanding data quality and accuracy&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationStatsApiResponse"/>&gt;</returns>
        public async Task<IGetLocationStatsApiResponse> GetLocationStatsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLocationStatsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Geolocation Database Statistics &lt;p&gt;Returns metadata and statistics about the geolocation database, including coverage, update frequency, and data quality metrics.&lt;/p&gt; &lt;h4&gt;Statistics Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Coverage:&lt;/b&gt; Total IP addresses, networks, and ASNs covered&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Number of countries, cities, and regions&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Freshness:&lt;/b&gt; Last update timestamp and update frequency&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Data Sources:&lt;/b&gt; Providers and data collection methods&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Accuracy:&lt;/b&gt; Quality metrics and confidence scores&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Verifying database coverage for your use case&lt;/li&gt;     &lt;li&gt;Monitoring data freshness&lt;/li&gt;     &lt;li&gt;Understanding data quality and accuracy&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocationStatsApiResponse"/>&gt;</returns>
        public async Task<IGetLocationStatsApiResponse> GetLocationStatsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/location/stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/location/stats");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetLocationStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLocationStatsApiResponse>();
                        GetLocationStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/location/stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetLocationStatsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetLocationStats(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLocationStatsDefaultImplementation(e, "/v1/location/stats", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetLocationStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLocationStatsApiResponse"/>
        /// </summary>
        public partial class GetLocationStatsApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IGetLocationStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLocationStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLocationStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocationStatsApiResponse(ILogger<GetLocationStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetLocationStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocationStatsApiResponse(ILogger<GetLocationStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetNetworkLocation(ref string network);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="network"></param>
        /// <returns></returns>
        private void ValidateGetNetworkLocation(string network)
        {
            if (network == null)
                throw new ArgumentNullException(nameof(network));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="network"></param>
        private void AfterGetNetworkLocationDefaultImplementation(IGetNetworkLocationApiResponse apiResponseLocalVar, string network)
        {
            bool suppressDefaultLog = false;
            AfterGetNetworkLocation(ref suppressDefaultLog, apiResponseLocalVar, network);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="network"></param>
        partial void AfterGetNetworkLocation(ref bool suppressDefaultLog, IGetNetworkLocationApiResponse apiResponseLocalVar, string network);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="network"></param>
        private void OnErrorGetNetworkLocationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string network)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetNetworkLocation(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, network);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="network"></param>
        partial void OnErrorGetNetworkLocation(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string network);

        /// <summary>
        /// Get Network/CIDR Geolocation Data &lt;p&gt;Returns geolocation and network information for an entire network range specified in CIDR notation. Useful for analyzing network blocks, ranges, and subnets.&lt;/p&gt; &lt;h4&gt;Supported Formats:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;IPv4 CIDR:&lt;/b&gt; 192.168.1.0/24&lt;/li&gt;     &lt;li&gt;&lt;b&gt;IPv6 CIDR:&lt;/b&gt; 2001:db8::/32&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Data Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Network Details:&lt;/b&gt; CIDR range, first/last IP, total addresses&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Country, city, region for the network block&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; ASN, organization, ISP information&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Classification:&lt;/b&gt; Network type and usage category&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Analyzing suspicious network ranges&lt;/li&gt;     &lt;li&gt;Bulk geolocation for network blocks&lt;/li&gt;     &lt;li&gt;Infrastructure mapping and reconnaissance&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <param name="network">The network range in CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32).</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkLocationApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkLocationApiResponse> GetNetworkLocationOrDefaultAsync(string network, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetNetworkLocationAsync(network, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Network/CIDR Geolocation Data &lt;p&gt;Returns geolocation and network information for an entire network range specified in CIDR notation. Useful for analyzing network blocks, ranges, and subnets.&lt;/p&gt; &lt;h4&gt;Supported Formats:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;IPv4 CIDR:&lt;/b&gt; 192.168.1.0/24&lt;/li&gt;     &lt;li&gt;&lt;b&gt;IPv6 CIDR:&lt;/b&gt; 2001:db8::/32&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Data Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Network Details:&lt;/b&gt; CIDR range, first/last IP, total addresses&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; Country, city, region for the network block&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; ASN, organization, ISP information&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Classification:&lt;/b&gt; Network type and usage category&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Analyzing suspicious network ranges&lt;/li&gt;     &lt;li&gt;Bulk geolocation for network blocks&lt;/li&gt;     &lt;li&gt;Infrastructure mapping and reconnaissance&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="network">The network range in CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32).</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetNetworkLocationApiResponse"/>&gt;</returns>
        public async Task<IGetNetworkLocationApiResponse> GetNetworkLocationAsync(string network, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetNetworkLocation(network);

                FormatGetNetworkLocation(ref network);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/location/network/{network}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/location/network/{network}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bnetwork%7D", Uri.EscapeDataString(network.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetNetworkLocationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetNetworkLocationApiResponse>();
                        GetNetworkLocationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/location/network/{network}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetNetworkLocationDefaultImplementation(apiResponseLocalVar, network);

                        Events.ExecuteOnGetNetworkLocation(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetNetworkLocationDefaultImplementation(e, "/v1/location/network/{network}", uriBuilderLocalVar.Path, network);
                Events.ExecuteOnErrorGetNetworkLocation(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetNetworkLocationApiResponse"/>
        /// </summary>
        public partial class GetNetworkLocationApiResponse : Whisper.Api.Sdk.Client.ApiResponse, IGetNetworkLocationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetNetworkLocationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetNetworkLocationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkLocationApiResponse(ILogger<GetNetworkLocationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetNetworkLocationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetNetworkLocationApiResponse(ILogger<GetNetworkLocationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSearchLocation(ref string field, ref string value, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="field"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        private void ValidateSearchLocation(string field, string value)
        {
            if (field == null)
                throw new ArgumentNullException(nameof(field));

            if (value == null)
                throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="field"></param>
        /// <param name="value"></param>
        /// <param name="limit"></param>
        private void AfterSearchLocationDefaultImplementation(ISearchLocationApiResponse apiResponseLocalVar, string field, string value, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterSearchLocation(ref suppressDefaultLog, apiResponseLocalVar, field, value, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="field"></param>
        /// <param name="value"></param>
        /// <param name="limit"></param>
        partial void AfterSearchLocation(ref bool suppressDefaultLog, ISearchLocationApiResponse apiResponseLocalVar, string field, string value, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="field"></param>
        /// <param name="value"></param>
        /// <param name="limit"></param>
        private void OnErrorSearchLocationDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string field, string value, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSearchLocation(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, field, value, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="field"></param>
        /// <param name="value"></param>
        /// <param name="limit"></param>
        partial void OnErrorSearchLocation(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string field, string value, Option<int> limit);

        /// <summary>
        /// Search Geolocation Database by Field &lt;p&gt;Search the geolocation database by specific fields to find all IP addresses matching your criteria. Powerful for threat hunting, infrastructure discovery, and pattern analysis.&lt;/p&gt; &lt;h4&gt;Searchable Fields:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; city, country, country_code, region, postal_code, continent, continent_code&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; asn, as_number, organization, isp, isp_name&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Coordinates:&lt;/b&gt; latitude, longitude&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Query Examples:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Find all IPs in a city:&lt;/b&gt; field&#x3D;city&amp;value&#x3D;London&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs for an ASN:&lt;/b&gt; field&#x3D;asn&amp;value&#x3D;15169&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs for an ISP:&lt;/b&gt; field&#x3D;isp_name&amp;value&#x3D;Google&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs in country:&lt;/b&gt; field&#x3D;country_code&amp;value&#x3D;US&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; 200-500ms depending on result size&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Rate Limit:&lt;/b&gt; 5 searches per minute&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Infrastructure mapping for threat actors&lt;/li&gt;     &lt;li&gt;Finding all IPs in a specific region for compliance&lt;/li&gt;     &lt;li&gt;Discovering VPN/proxy exit nodes&lt;/li&gt;     &lt;li&gt;Threat hunting by ISP or ASN&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <param name="field">The field to search. Valid fields: city, country, country_code, isp_name, isp, asn, as_number, organization, continent, continent_code, region, postal_code, latitude, longitude</param>
        /// <param name="value">The value to search for in the specified field.</param>
        /// <param name="limit">Maximum number of results to return. (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchLocationApiResponse"/>&gt;</returns>
        public async Task<ISearchLocationApiResponse> SearchLocationOrDefaultAsync(string field, string value, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SearchLocationAsync(field, value, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search Geolocation Database by Field &lt;p&gt;Search the geolocation database by specific fields to find all IP addresses matching your criteria. Powerful for threat hunting, infrastructure discovery, and pattern analysis.&lt;/p&gt; &lt;h4&gt;Searchable Fields:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Geographic:&lt;/b&gt; city, country, country_code, region, postal_code, continent, continent_code&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Network:&lt;/b&gt; asn, as_number, organization, isp, isp_name&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Coordinates:&lt;/b&gt; latitude, longitude&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Query Examples:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Find all IPs in a city:&lt;/b&gt; field&#x3D;city&amp;value&#x3D;London&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs for an ASN:&lt;/b&gt; field&#x3D;asn&amp;value&#x3D;15169&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs for an ISP:&lt;/b&gt; field&#x3D;isp_name&amp;value&#x3D;Google&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Find all IPs in country:&lt;/b&gt; field&#x3D;country_code&amp;value&#x3D;US&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Response Time:&lt;/b&gt; 200-500ms depending on result size&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Rate Limit:&lt;/b&gt; 5 searches per minute&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Infrastructure mapping for threat actors&lt;/li&gt;     &lt;li&gt;Finding all IPs in a specific region for compliance&lt;/li&gt;     &lt;li&gt;Discovering VPN/proxy exit nodes&lt;/li&gt;     &lt;li&gt;Threat hunting by ISP or ASN&lt;/li&gt; &lt;/ul&gt; 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="field">The field to search. Valid fields: city, country, country_code, isp_name, isp, asn, as_number, organization, continent, continent_code, region, postal_code, latitude, longitude</param>
        /// <param name="value">The value to search for in the specified field.</param>
        /// <param name="limit">Maximum number of results to return. (optional, default to 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISearchLocationApiResponse"/>&gt;</returns>
        public async Task<ISearchLocationApiResponse> SearchLocationAsync(string field, string value, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSearchLocation(field, value);

                FormatSearchLocation(ref field, ref value, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/location/search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/location/search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["field"] = ClientUtils.ParameterToString(field);
                    parseQueryStringLocalVar["value"] = ClientUtils.ParameterToString(value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SearchLocationApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SearchLocationApiResponse>();
                        SearchLocationApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/location/search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSearchLocationDefaultImplementation(apiResponseLocalVar, field, value, limit);

                        Events.ExecuteOnSearchLocation(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSearchLocationDefaultImplementation(e, "/v1/location/search", uriBuilderLocalVar.Path, field, value, limit);
                Events.ExecuteOnErrorSearchLocation(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SearchLocationApiResponse"/>
        /// </summary>
        public partial class SearchLocationApiResponse : Whisper.Api.Sdk.Client.ApiResponse, ISearchLocationApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SearchLocationApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SearchLocationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchLocationApiResponse(ILogger<SearchLocationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SearchLocationApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SearchLocationApiResponse(ILogger<SearchLocationApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse TooManyRequests()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsTooManyRequests
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryTooManyRequests([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = TooManyRequests();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)429);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Whisper.Api.Sdk.Model.ErrorResponse Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Whisper.Api.Sdk.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Whisper.Api.Sdk.Model.ErrorResponse result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
